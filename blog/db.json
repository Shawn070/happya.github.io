{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":0,"renderable":1},{"_id":"source/image/sleepy-lion.jpg","path":"image/sleepy-lion.jpg","modified":0,"renderable":0},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"source/assets/img/alipay.jpg","path":"assets/img/alipay.jpg","modified":0,"renderable":0},{"_id":"source/assets/img/wechat.jpg","path":"assets/img/wechat.jpg","modified":0,"renderable":0},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"44cbf809263542c3536de7105a731f8ffc9477ce","modified":1516074182828},{"_id":"themes/yilia/.editorconfig","hash":"daaa8757fac18f8735fadd0a37a42c06f421ca14","modified":1516207201133},{"_id":"themes/yilia/.babelrc","hash":"db600d40e93e6d8023737a65d58d3be7370e5e30","modified":1516207201133},{"_id":"themes/yilia/.eslintignore","hash":"ed9d8911ca08c3dd5072c48dd0be4d06f8897730","modified":1516207201133},{"_id":"themes/yilia/.gitattributes","hash":"758cfbecfa7919e99abddf3297f37cde7e3d8d4e","modified":1516207201133},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1516207201148},{"_id":"themes/yilia/.gitignore","hash":"d5fc575329853ff620b50fc62ad4b18fa09a308a","modified":1516207201148},{"_id":"themes/yilia/_config.yml","hash":"7ab520e206e19939fa4221814df25c4a0229aaf4","modified":1516205325919},{"_id":"themes/yilia/package.json","hash":"ee6aa61f1cb89fd549e3e087c0232207a9c9ee30","modified":1516207201164},{"_id":"themes/yilia/.eslintrc.js","hash":"303d25adf02ad65720e537a16a4a137d14bb755f","modified":1516207201133},{"_id":"source/_posts/Leetcode之旅-链表啊，链表-2.md","hash":"df554a83be47f9c99658e9b90ce5787ef4d36a12","modified":1516289197087},{"_id":"source/_posts/Gap-Gap-Gap.md","hash":"02151fbecb3ed5e44fca1c92501a842ad045e254","modified":1516116886219},{"_id":"source/_posts/Brainy-is-the-new-sexy.md","hash":"c796b0d9d3b67cb145d71bd5f2da95e6d5c2a9a1","modified":1516198022164},{"_id":"source/_posts/Leetcode之旅：数据结构之P25.md","hash":"7a0d67c849d2a62476126e7c8b4614aac6a1c7c3","modified":1516285300172},{"_id":"source/_posts/Leetcode之旅-链表啊，链表！.md","hash":"ab3b2923dc8d9496f9c0ec0efeaeec9441f94248","modified":1516204012570},{"_id":"source/_posts/关于最近薛之谦事件的一点看法.md","hash":"77a21cce43a14844452b98a87a71652d31a0c3de","modified":1516074182893},{"_id":"source/_posts/PRML-之无处不在的高斯分布.md","hash":"165f620934a1c14fdb21a64312a5f95cfc0598a0","modified":1516074182892},{"_id":"source/_posts/最近英语学习的一点心得.md","hash":"b2f05f41cc6bb9f308c47dcc1f9b45c876df8e50","modified":1516074182894},{"_id":"source/_posts/矩阵计算的小糖果.md","hash":"2171ad7d98248af8b76b943391a8774017cd27ec","modified":1516074182895},{"_id":"source/_posts/降维打击之LLE算法.md","hash":"d907840b678ab13a2059d447e4fecac83f4f8e6a","modified":1516074182895},{"_id":"themes/yilia/.git/FETCH_HEAD","hash":"cbcf599b2a3712cfe2c5f7190b740af26fc00422","modified":1516207323299},{"_id":"themes/yilia/webpack.config.js","hash":"da7657347109ddb4ab8602b219778117254677fe","modified":1516207201195},{"_id":"themes/yilia/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1516207201117},{"_id":"themes/yilia/.git/ORIG_HEAD","hash":"4ed77da1a2617db0e77c3e3e190a1c79c16dfb9a","modified":1516207333572},{"_id":"themes/yilia/.git/config","hash":"48a197595af8361d260a2f2c0298a245d578c786","modified":1516207295188},{"_id":"themes/yilia/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1516206796980},{"_id":"themes/yilia/.git/index","hash":"a7dc8b7a76d54ba3c0d7c8579bed6aaa967c64f5","modified":1516285323404},{"_id":"themes/yilia/.git/packed-refs","hash":"83644c3638dafa38c817265c9207f098dd8aeee6","modified":1516207201117},{"_id":"themes/yilia/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1516207201148},{"_id":"themes/yilia/languages/fr.yml","hash":"b4be1c1592a72012e48df2b3ec41cc9685573e50","modified":1516207201148},{"_id":"themes/yilia/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1516207201148},{"_id":"themes/yilia/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1516207201148},{"_id":"themes/yilia/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1516207201148},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1516207201148},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1516207201148},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1516207201164},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1516207201164},{"_id":"themes/yilia/layout/index.ejs","hash":"ec498c6c0606acde997ce195dad97b267418d980","modified":1516207201164},{"_id":"themes/yilia/layout/layout.ejs","hash":"b471ab706d48e0be3f783eab1c94bf5878ef5a94","modified":1516207201164},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1516207201164},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1516207201164},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1516207201164},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1516207201195},{"_id":"themes/yilia/source-src/css.ejs","hash":"cf7eab48d626433120d1ef9697f719a359817018","modified":1516207201164},{"_id":"themes/yilia/source-src/script.ejs","hash":"28abac2426761d7e715b38aadd86ce6549c8ae77","modified":1516207201195},{"_id":"source/image/sleepy-lion.jpg","hash":"745eb7f48296276ebf40d3c6b2fe86a0c4a43334","modified":1516074182907},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516207201164},{"_id":"themes/yilia/source/slider.e37972.js","hash":"ce5eac88301fe4f2fce0fb6203adfd58eb8313ac","modified":1516207201195},{"_id":"themes/yilia/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1516206796980},{"_id":"themes/yilia/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1516206796980},{"_id":"themes/yilia/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1516206796980},{"_id":"themes/yilia/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1516206796980},{"_id":"themes/yilia/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1516206796980},{"_id":"themes/yilia/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1516206796980},{"_id":"themes/yilia/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1516206796980},{"_id":"themes/yilia/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1516206796980},{"_id":"themes/yilia/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1516206796980},{"_id":"themes/yilia/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1516206796980},{"_id":"themes/yilia/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1516206796980},{"_id":"themes/yilia/.git/logs/HEAD","hash":"0c48a441385b7649fbcc2bb1a8fb58f52d05e5eb","modified":1516207201117},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"c70f367f54064a441e574c913f5e0ea121d0f899","modified":1516207201148},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"edc0154b30a4127acda10297bec6aacf754b4ac4","modified":1516207201148},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1516207201148},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"8dea8f5f93a60185439b330b0f1d1649a6ab4bd0","modified":1516207201148},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"751e5deab5365348be5243688b419c82d337ab9a","modified":1516207201148},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"155327c23607f69989b58845f24d842a54e504b8","modified":1516207201148},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1516207201148},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"871f81cacd5d41cb2eb001cd56254217a857dc2f","modified":1516207201148},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1516207201148},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"12ca7d8dba56bc767b9309dda9526dcbaffc1614","modified":1516207201148},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"b69855e07b65117769adc515cb64b803932068c9","modified":1516207201148},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"fb1b8457b9eb15b55da1bf7b133e12c375dd26f8","modified":1516207201148},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"11550a418921d330e6553be0569a94ab5a217967","modified":1516207201148},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"ccec1fc70f021cb50ac85b524e7949878ab93a18","modified":1516207201148},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"0ffcb251b79e8a920c9b4cb6bb7a96a808816165","modified":1516207201164},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"cc1c39903aed0a0601d104238d2bbd13ad2a36f3","modified":1516207201164},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1516207201195},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1516207201195},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1516207201195},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1516207201195},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1516207201195},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1516207201195},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1516207201195},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1516207201195},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1516207201195},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"29ba600e98ed55f7af4ade8038272c84cba21188","modified":1516207201164},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"ce227b6f5a9af194fd5d455200630f32c05e151f","modified":1516207201164},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"d6a7dd88404b383b5b94e4c7ec675a410c41f3cc","modified":1516207201164},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"f7388f5c11370ef462f7cb913d8f72edf24ecaf9","modified":1516207201164},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"1577a2336b3ad122f49f60dff2bc1a97d4e7b18b","modified":1516207201164},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"8f82fe898ba1c1bd00c24a7d8270feddc7eba3bc","modified":1516207201164},{"_id":"themes/yilia/source-src/css/article.scss","hash":"55d082fec4c6bb341725567acaa29ce37d50320a","modified":1516207201164},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"07244c188f58ecfb90bb7c047b8cde977f1dc4b4","modified":1516207201164},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"96d7eb1d42c06fdcccb8ef969f6ecd30c3194903","modified":1516207201164},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1516207201179},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"b85f344f2c66d43d7094746e0a9ccb21d0534201","modified":1516207201164},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"f53ea8270752b5919ec5d79224d22af91f2eda12","modified":1516207201179},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1516207201179},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"40e5aa5056dc0b3b9f51c5b387370b612e265d4e","modified":1516207201179},{"_id":"themes/yilia/source-src/css/left.scss","hash":"80dac621e43581a254d0152d5df901e4d0b01c09","modified":1516207201179},{"_id":"themes/yilia/source-src/css/main.scss","hash":"9eba1fcf4805256697528fcf3b767cf6dd8d0591","modified":1516207201179},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"19f10fd2f0c3377aa4b165b3c2291ecf86dd9351","modified":1516207201179},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"d995dcd483a250fe61b426158afb61bf8923a927","modified":1516207201179},{"_id":"themes/yilia/source-src/css/page.scss","hash":"244c4d75c375978ff9edb74acc68825e63c6b235","modified":1516207201179},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"a557a9ed244c82b8b71e9da9de3339d92783499f","modified":1516207201179},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"2495f7e4e3b055735c531f944b5f40a118a351ec","modified":1516207201179},{"_id":"themes/yilia/source-src/css/share.scss","hash":"9d6f6884f40c191882e56a1e1e1192400944a515","modified":1516207201179},{"_id":"themes/yilia/source-src/css/social.scss","hash":"a10a038a1dac8953cb4ffc7e04272eff9fac54e4","modified":1516207201179},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"399744e98e7c67939ed9b23c2670d8baad044eda","modified":1516207201179},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"915c93edd67c5326695cc7dc84b14c5f154dbcc8","modified":1516207201179},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"2924fb6f77c4a9973cd928c2c7db0acb848ed483","modified":1516207201179},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"b81cedbe31accca82e597801186911a7b5e6841c","modified":1516207201179},{"_id":"themes/yilia/source-src/js/anm.js","hash":"d18f6276a352b871390a4112d479b9e58b8cdbbe","modified":1516207201179},{"_id":"themes/yilia/source-src/js/aside.js","hash":"5e4c3c3d61f1e1ce2f09688d3aff25fadc851fff","modified":1516207201179},{"_id":"themes/yilia/source-src/js/browser.js","hash":"4dc04845cf27f350922b63f1813a9c82e6e33b05","modified":1516207201179},{"_id":"themes/yilia/source-src/js/fix.js","hash":"67b8819abb886c9d066fb3b0624ca15e06f63fe0","modified":1516207201195},{"_id":"themes/yilia/source-src/js/main.js","hash":"fe98bf90ce61658fe16ae057f8b6a512a845af3b","modified":1516207201195},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"461c08ffcbc724d74ec7e0ff38e171eefe0f89fd","modified":1516207201195},{"_id":"themes/yilia/source-src/js/share.js","hash":"d4ccff8266c37363b3904226f5d035b7db882c61","modified":1516207201195},{"_id":"themes/yilia/source-src/js/Q.js","hash":"e56d9710afa79b31ca6b9fbd845f6d1895f5214b","modified":1516207201179},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"c699cf3c89409ec8f044258e0715a470861b5d5d","modified":1516207201195},{"_id":"themes/yilia/source-src/js/report.js","hash":"57680f9a23bd0a1eaafd64ae08cc33e20627ab15","modified":1516207201195},{"_id":"themes/yilia/source-src/js/util.js","hash":"3bcdeb95072b85600874424e6929e3e22cfddaa0","modified":1516207201195},{"_id":"source/assets/img/alipay.jpg","hash":"4b233586926b0dae7b39775bade6b44addad04ca","modified":1516074182899},{"_id":"source/assets/img/wechat.jpg","hash":"140cb6c9fdbf8cf82d6417fc4063352d0ff6b19f","modified":1516074182903},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"283ae27ea37ac3e0e45b2e05c2482a4c594b9c25","modified":1516207201195},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"e98ec0b3b56f14d1d79af99ceb42727719a584f3","modified":1516207201164},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"1801ef448909ea23c0a48e9d63b80d0cfd5534ce","modified":1516207201195},{"_id":"themes/yilia/source-src/js/slider.js","hash":"0beaa112657ad57c723d9e773d5b79de60c1dd74","modified":1516207201195},{"_id":"themes/yilia/.git/objects/pack/pack-f4c1f8e0be0539cf03f0ee67a74dafa26a557a10.idx","hash":"991e526fbc58371dd8a596e2a0d5a52931821575","modified":1516207201054},{"_id":"themes/yilia/.git/refs/heads/master","hash":"4ed77da1a2617db0e77c3e3e190a1c79c16dfb9a","modified":1516207201117},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"aae96de18d48cd3b9b7bf6fed0100e15b53cca97","modified":1516207201148},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"086c8a88fd3bcae7ec13258df58e25d6354af2fa","modified":1516207201148},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"e777cbf959b11c4dfda649c562799899b90ab4a3","modified":1516207201148},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"f6b4c4eaafb5ac386273354b5f64a26139b7a3b0","modified":1516207201148},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"25655016773aa5d0774c56115ae1736a9fc9ea1f","modified":1516207201148},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"b6a97043f9ec37e571aacacfedcda1d4d75e3c7c","modified":1516207201148},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"345b262e3c3b75c0cd9a93d9ecabcf06e33e54ff","modified":1516207201148},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2c4e4ca36c9bb4318506c38aca7127f1f44d827f","modified":1516207201148},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1516207201164},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"fb022502c741b4a26bad6b2ad37245c10ede3f1a","modified":1516207201164},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"1834c3ed8560716e63bb3a50be94cac87fbbeaf3","modified":1516207201164},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"91db061c9c17628291a005e5bd4936cf9d35a6c4","modified":1516207201164},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"398a49913b4a47d928103562b1ce94520be4026a","modified":1516207201164},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"6e75bdaa46de83094ba0873099c6e7d656a22453","modified":1516207201164},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"262ffcd88775080b7f511db37f58d2bcb1b2bfc7","modified":1516207201164},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1516207201179},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1516207201179},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1516207201179},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1516207201179},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1516207201179},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1516207201179},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1516207201179},{"_id":"themes/yilia/.git/logs/refs/heads/master","hash":"0c48a441385b7649fbcc2bb1a8fb58f52d05e5eb","modified":1516207201117},{"_id":"themes/yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1516207201117},{"_id":"themes/yilia/.git/refs/remotes/upstream/master","hash":"4ed77da1a2617db0e77c3e3e190a1c79c16dfb9a","modified":1516207323283},{"_id":"themes/yilia/.git/refs/remotes/upstream/myself","hash":"d9893970a3f49fee45d449931381c471db51e5ec","modified":1516207323299},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/HEAD","hash":"0c48a441385b7649fbcc2bb1a8fb58f52d05e5eb","modified":1516207201117},{"_id":"themes/yilia/.git/logs/refs/remotes/upstream/myself","hash":"dede712c78a5ef43faef55404bc340ea5b45927f","modified":1516207323299},{"_id":"themes/yilia/.git/logs/refs/remotes/upstream/master","hash":"287cf28db03a3bd8c3ddc0c74c65f67ae0fcb8ce","modified":1516207323299},{"_id":"themes/yilia/.git/objects/pack/pack-f4c1f8e0be0539cf03f0ee67a74dafa26a557a10.pack","hash":"22f8ad7f2b3174a246f4463f06f18d453a074033","modified":1516207201070},{"_id":"public/content.json","hash":"11b7dc86786b8a4447293bae5aafbfadd4b79d97","modified":1516289048811},{"_id":"public/2018/01/17/Leetcode之旅-链表啊，链表！/index.html","hash":"33c81cc8dea492397c44c8cdccfc1231adfbf621","modified":1516289049319},{"_id":"public/2018/01/16/Gap-Gap-Gap/index.html","hash":"84fa5e384340a1b1f6f1162c45dc1ca2febc9785","modified":1516289049319},{"_id":"public/2018/01/15/Leetcode之旅：数据结构之P25/index.html","hash":"18954b06b0607cf776ae95ac37d53e80c8937df6","modified":1516289049366},{"_id":"public/2017/11/10/矩阵计算的小糖果/index.html","hash":"f0147bc6a822c15bf04aa043b0280dd77495bbff","modified":1516289049381},{"_id":"public/2017/10/21/PRML-之无处不在的高斯分布/index.html","hash":"ea41cf2e62a311e9bb1652c612876543576a4344","modified":1516289049381},{"_id":"public/2017/09/29/降维打击之LLE算法/index.html","hash":"e58cb53e49e8e30bfade109987a6dfdb817cee50","modified":1516289049381},{"_id":"public/2017/09/23/关于最近薛之谦事件的一点看法/index.html","hash":"9969e4742d626dedc2b1e4a831e56c852d77fcda","modified":1516289049381},{"_id":"public/2017/09/21/最近英语学习的一点心得/index.html","hash":"6d72feaf79b1be4d3654fe6a76d14671028d6403","modified":1516289049381},{"_id":"public/2017/09/20/Brainy-is-the-new-sexy/index.html","hash":"15531b92094c5b58c6d9a0e8e4280f62298dc822","modified":1516289049381},{"_id":"public/categories/Leetcode/index.html","hash":"9d8ef90e5a3fa24d7d16f04c17849e5ba8ecf3f3","modified":1516289049381},{"_id":"public/categories/英语学习/index.html","hash":"c8600590720030525b0b0b341839a7b81208626d","modified":1516289049381},{"_id":"public/archives/index.html","hash":"d72f3db5a9a74b3bd777e5aee3e482a105332834","modified":1516289049381},{"_id":"public/archives/2017/09/index.html","hash":"d1e4ded5951e3879052b9ef425545071b6ad92f2","modified":1516289049381},{"_id":"public/archives/2017/10/index.html","hash":"1717a6b5f4677539fd54d58717d8d6c743bcecc7","modified":1516289049381},{"_id":"public/archives/2017/11/index.html","hash":"8fb31725162d88d77f516d808f6b1524fd2ae0dc","modified":1516289049381},{"_id":"public/archives/2018/index.html","hash":"789d0ad74f4eb05c440c41b0abc654599fd1215a","modified":1516289049381},{"_id":"public/archives/2018/01/index.html","hash":"f368d4e5b7c73b397f11a4de28f42a6da593ef4d","modified":1516289049381},{"_id":"public/index.html","hash":"6ca4c0b5293795dac291769f0bb7f9510e4c724c","modified":1516289209319},{"_id":"public/tags/Leetcode/index.html","hash":"60accefa4923a3384c217d1fdf7a5adb3fe188dc","modified":1516289049381},{"_id":"public/tags/Data-Structure/index.html","hash":"5f58d36c0fd93682b9259974ac1c1c5b122dbc09","modified":1516289049381},{"_id":"public/tags/随笔/index.html","hash":"41c81b878ca0c6879bde62484c9eec9a5fa35d71","modified":1516289049381},{"_id":"public/archives/2017/index.html","hash":"01c5fca5d31a78e0ae8b574bc42f733f2528d200","modified":1516289049381},{"_id":"public/tags/algorithm/index.html","hash":"7256cbe6d3ba9db80fee571e7c6fd1ebe12e334b","modified":1516289049381},{"_id":"public/tags/机器学习/index.html","hash":"5f0b504e6da05f32555a0dc79590bd5f1882ce40","modified":1516289049381},{"_id":"public/tags/英语学习/index.html","hash":"0eaddf3beea2797a796aee86b17a80e4a924ff0f","modified":1516289049381},{"_id":"public/tags/降维算法/index.html","hash":"5e83d3234ae2c59798d6822f314f9512f386fecc","modified":1516289049381},{"_id":"public/2018/01/18/Leetcode之旅-链表啊，链表-2/index.html","hash":"82d84600c5f7023e82315bea6ec3ef684a2f67ae","modified":1516289209319},{"_id":"public/tags/Linked-list/index.html","hash":"b4a8f24105928019b3953a0fb718e92319b51965","modified":1516289049404},{"_id":"public/tags/读书笔记/index.html","hash":"e5d0b19c9cd950270b2c5daaaf5b90f18d00ac49","modified":1516289049404},{"_id":"public/tags/娱乐八卦/index.html","hash":"8386fa158d9725e5d557b8e5bac0c41181eb425a","modified":1516289049404},{"_id":"public/CNAME","hash":"44cbf809263542c3536de7105a731f8ffc9477ce","modified":1516289049404},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1516289049404},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1516289049404},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1516289049404},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1516289049404},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1516289049404},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1516289049404},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1516289049404},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1516289049404},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1516289049404},{"_id":"public/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1516289049419},{"_id":"public/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1516289049419},{"_id":"public/image/sleepy-lion.jpg","hash":"745eb7f48296276ebf40d3c6b2fe86a0c4a43334","modified":1516289049419},{"_id":"public/assets/img/alipay.jpg","hash":"4b233586926b0dae7b39775bade6b44addad04ca","modified":1516289049419},{"_id":"public/assets/img/wechat.jpg","hash":"140cb6c9fdbf8cf82d6417fc4063352d0ff6b19f","modified":1516289049419},{"_id":"public/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1516289049451},{"_id":"public/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1516289049451}],"Category":[{"name":"Leetcode","_id":"cjcknckyu0005souysuyiomkp"},{"name":"英语学习","_id":"cjcknckza000csouyjf1slek3"}],"Data":[],"Page":[],"Post":[{"title":"Leetcode之旅|链表啊，链表! (2)","date":"2018-01-18T14:25:08.000Z","mathjax":true,"_content":"\n　　今天记录的是两道特别有意思的题：判断链表中存不存在环(circle)。为了找解法，在纸上画了各种数字、箭头、圈圈和推导，还以为在研究什么彩票号码呢哈哈 ~ ~ ~\n\n## 题目描述\n\n　　和昨天一样，今天的两道题同样是分为基础版和进阶版，不同的是，今天的两个版本可以看作是一道大题的两小问，二者关联性更强。\n\n>　　基础版：\n> 　　\n> 　　　　判断链表是否存在环。([141. Linked list cycle](https://leetcode.com/problems/linked-list-cycle/description//))\n> 　\n>　　进阶版：\n>　　\n>　　　　若存在环，找出环的起点。([142. Linked list cycle II](https://leetcode.com/problems/linked-list-cycle-ii/description/))　　 　 　\n\n　　另外，要求在不修改链表的同时，空间复杂度为$O(1)$。\n\n## 解题思路\n\n### 基础版\n\n　　这道题我一开始是联想到了之前学习DFS的思路，即遍历每个节点，并在访问后做上visited的标记，如果访问到一个已经标记的节点，说明有环。然而想法是美好的，不，也并不美好，毕竟这个空间复杂度不是$O(1)$，而且发现没那么好实现，因为单向链表的特点就是不能回头，你很容易知道一个节点的下一个节点是啥，但前一个节点是啥？不能直接知道。\n\n　　后来逛了下别人的答案，感觉自己被羞辱了，思路完全不一样啊！完全没这么想啊！看来还是经验不够啊！(受打击三连)又学习到了。具体怎么做呢？需要用到两个指针，一个每次走一步(slow)，另一个走得快一点，每次走两步(fast)，咳咳，重点来了 ~ 如果一个链表不存在环，那总会走向终点(遇到Null)；如果存在环呢？那两个指针会一直走下去，但这样循环没法终止，就没法返回结果，所以进一步的判断依据是，如果存在环，slow和fast两个指针会相遇，一旦相遇，循环终止，即可返回结果。代码如下：\n\n```python\ndef hasCycle(head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        slow, fast = head, head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow==fast:\n                return True\n        return False\n```\n\n### 进阶版\n\n　　虽然有了基础版的打底，但进阶版也折腾了我很久，最后还是借了别人的智慧才解决的，唉，心塞。 和基础版一样，我们需要设置两个指针，均初始化为head(如果有的话)，因为没有环的情况很好判断，我们接下来只讨论在有环的情况下，如何找环的起始点。\n\n　　将head看作第一个节点，那么如果走$T-1$步的话，slow将会到达第$T$个节点，而fast会到达第$2T-1$个节点。当二者第一次相遇(meet)，设在第$M$个节点，那么slow和fast的距离为$M-1$个节点，那么$M-1$一定是环的节点个数(C)的整数倍，即：\n\n$$M-1 = nC, n \\ge 1$$\n\n这时候我们再设一个指针_head，初始为第一个节点的位置(head),那么此时slow(或者fast,因为循环终止条件是二者相同)与_head的距离为$nC$。此时再分两种情况讨论。\n\n- 如果第一次相遇的点就是head，那么说明head就是环的入口,直接返回head即可。这点很好理解。\n- 如果第一次相遇的不是head，,那么让_head和slow以相同速度前进，当_head到达环的入口时，因为slow和head的距离为$nC$，那么二者必然相遇。 因为对于_head而言，之前没有相遇的机会，所以第一次相遇的点必然是入口，返回_head即可。\n\n　　代码如下：\n\n```python\ndef detectCycle(head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        slow, fast = head, head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            \n            if slow == fast:\n                break\n        \n        if not fast or not fast.next:\n            return None\n        \n        if head == slow:\n            return head\n        _head = head\n        while _head != slow:\n            _head = _head.next\n            slow = slow.next\n        return _head\n```\n\n## 总结\n\n　　刷完链表就刷树和图吧，数据结构太有意思了。记得之前我关注的一个博主曾在合理使用堆栈给出某道题很elegant的解法时感慨：“啊，这就是数据结构的胜利！！！”而我目前还只是在练习一些很简单的操作，希望我以后也能将它们变为趁手的利刃吧。","source":"_posts/Leetcode之旅-链表啊，链表-2.md","raw":"---\ntitle: Leetcode之旅|链表啊，链表! (2)\ndate: 2018-01-18 22:25:08\ntags:\n    - Leetcode\n    - Data Structure\n    - Linked list\n    - 随笔\nmathjax: true\n---\n\n　　今天记录的是两道特别有意思的题：判断链表中存不存在环(circle)。为了找解法，在纸上画了各种数字、箭头、圈圈和推导，还以为在研究什么彩票号码呢哈哈 ~ ~ ~\n\n## 题目描述\n\n　　和昨天一样，今天的两道题同样是分为基础版和进阶版，不同的是，今天的两个版本可以看作是一道大题的两小问，二者关联性更强。\n\n>　　基础版：\n> 　　\n> 　　　　判断链表是否存在环。([141. Linked list cycle](https://leetcode.com/problems/linked-list-cycle/description//))\n> 　\n>　　进阶版：\n>　　\n>　　　　若存在环，找出环的起点。([142. Linked list cycle II](https://leetcode.com/problems/linked-list-cycle-ii/description/))　　 　 　\n\n　　另外，要求在不修改链表的同时，空间复杂度为$O(1)$。\n\n## 解题思路\n\n### 基础版\n\n　　这道题我一开始是联想到了之前学习DFS的思路，即遍历每个节点，并在访问后做上visited的标记，如果访问到一个已经标记的节点，说明有环。然而想法是美好的，不，也并不美好，毕竟这个空间复杂度不是$O(1)$，而且发现没那么好实现，因为单向链表的特点就是不能回头，你很容易知道一个节点的下一个节点是啥，但前一个节点是啥？不能直接知道。\n\n　　后来逛了下别人的答案，感觉自己被羞辱了，思路完全不一样啊！完全没这么想啊！看来还是经验不够啊！(受打击三连)又学习到了。具体怎么做呢？需要用到两个指针，一个每次走一步(slow)，另一个走得快一点，每次走两步(fast)，咳咳，重点来了 ~ 如果一个链表不存在环，那总会走向终点(遇到Null)；如果存在环呢？那两个指针会一直走下去，但这样循环没法终止，就没法返回结果，所以进一步的判断依据是，如果存在环，slow和fast两个指针会相遇，一旦相遇，循环终止，即可返回结果。代码如下：\n\n```python\ndef hasCycle(head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        slow, fast = head, head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow==fast:\n                return True\n        return False\n```\n\n### 进阶版\n\n　　虽然有了基础版的打底，但进阶版也折腾了我很久，最后还是借了别人的智慧才解决的，唉，心塞。 和基础版一样，我们需要设置两个指针，均初始化为head(如果有的话)，因为没有环的情况很好判断，我们接下来只讨论在有环的情况下，如何找环的起始点。\n\n　　将head看作第一个节点，那么如果走$T-1$步的话，slow将会到达第$T$个节点，而fast会到达第$2T-1$个节点。当二者第一次相遇(meet)，设在第$M$个节点，那么slow和fast的距离为$M-1$个节点，那么$M-1$一定是环的节点个数(C)的整数倍，即：\n\n$$M-1 = nC, n \\ge 1$$\n\n这时候我们再设一个指针_head，初始为第一个节点的位置(head),那么此时slow(或者fast,因为循环终止条件是二者相同)与_head的距离为$nC$。此时再分两种情况讨论。\n\n- 如果第一次相遇的点就是head，那么说明head就是环的入口,直接返回head即可。这点很好理解。\n- 如果第一次相遇的不是head，,那么让_head和slow以相同速度前进，当_head到达环的入口时，因为slow和head的距离为$nC$，那么二者必然相遇。 因为对于_head而言，之前没有相遇的机会，所以第一次相遇的点必然是入口，返回_head即可。\n\n　　代码如下：\n\n```python\ndef detectCycle(head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        slow, fast = head, head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            \n            if slow == fast:\n                break\n        \n        if not fast or not fast.next:\n            return None\n        \n        if head == slow:\n            return head\n        _head = head\n        while _head != slow:\n            _head = _head.next\n            slow = slow.next\n        return _head\n```\n\n## 总结\n\n　　刷完链表就刷树和图吧，数据结构太有意思了。记得之前我关注的一个博主曾在合理使用堆栈给出某道题很elegant的解法时感慨：“啊，这就是数据结构的胜利！！！”而我目前还只是在练习一些很简单的操作，希望我以后也能将它们变为趁手的利刃吧。","slug":"Leetcode之旅-链表啊，链表-2","published":1,"updated":"2018-01-18T15:26:37.087Z","_id":"cjcknckxz0000souy3koug13c","comments":1,"layout":"post","photos":[],"link":"","content":"<p>　　今天记录的是两道特别有意思的题：判断链表中存不存在环(circle)。为了找解法，在纸上画了各种数字、箭头、圈圈和推导，还以为在研究什么彩票号码呢哈哈 ~ ~ ~</p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>　　和昨天一样，今天的两道题同样是分为基础版和进阶版，不同的是，今天的两个版本可以看作是一道大题的两小问，二者关联性更强。</p>\n<blockquote>\n<p>　　基础版：<br>　　<br>　　　　判断链表是否存在环。(<a href=\"https://leetcode.com/problems/linked-list-cycle/description//\" target=\"_blank\" rel=\"noopener\">141. Linked list cycle</a>)<br>　<br>　　进阶版：<br>　　<br>　　　　若存在环，找出环的起点。(<a href=\"https://leetcode.com/problems/linked-list-cycle-ii/description/\" target=\"_blank\" rel=\"noopener\">142. Linked list cycle II</a>)　　 　 　</p>\n</blockquote>\n<p>　　另外，要求在不修改链表的同时，空间复杂度为$O(1)$。</p>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h3 id=\"基础版\"><a href=\"#基础版\" class=\"headerlink\" title=\"基础版\"></a>基础版</h3><p>　　这道题我一开始是联想到了之前学习DFS的思路，即遍历每个节点，并在访问后做上visited的标记，如果访问到一个已经标记的节点，说明有环。然而想法是美好的，不，也并不美好，毕竟这个空间复杂度不是$O(1)$，而且发现没那么好实现，因为单向链表的特点就是不能回头，你很容易知道一个节点的下一个节点是啥，但前一个节点是啥？不能直接知道。</p>\n<p>　　后来逛了下别人的答案，感觉自己被羞辱了，思路完全不一样啊！完全没这么想啊！看来还是经验不够啊！(受打击三连)又学习到了。具体怎么做呢？需要用到两个指针，一个每次走一步(slow)，另一个走得快一点，每次走两步(fast)，咳咳，重点来了 ~ 如果一个链表不存在环，那总会走向终点(遇到Null)；如果存在环呢？那两个指针会一直走下去，但这样循环没法终止，就没法返回结果，所以进一步的判断依据是，如果存在环，slow和fast两个指针会相遇，一旦相遇，循环终止，即可返回结果。代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hasCycle</span><span class=\"params\">(head)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type head: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        slow, fast = head, head</span><br><span class=\"line\">        <span class=\"keyword\">while</span> fast <span class=\"keyword\">and</span> fast.next:</span><br><span class=\"line\">            slow = slow.next</span><br><span class=\"line\">            fast = fast.next.next</span><br><span class=\"line\">            <span class=\"keyword\">if</span> slow==fast:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"进阶版\"><a href=\"#进阶版\" class=\"headerlink\" title=\"进阶版\"></a>进阶版</h3><p>　　虽然有了基础版的打底，但进阶版也折腾了我很久，最后还是借了别人的智慧才解决的，唉，心塞。 和基础版一样，我们需要设置两个指针，均初始化为head(如果有的话)，因为没有环的情况很好判断，我们接下来只讨论在有环的情况下，如何找环的起始点。</p>\n<p>　　将head看作第一个节点，那么如果走$T-1$步的话，slow将会到达第$T$个节点，而fast会到达第$2T-1$个节点。当二者第一次相遇(meet)，设在第$M$个节点，那么slow和fast的距离为$M-1$个节点，那么$M-1$一定是环的节点个数(C)的整数倍，即：</p>\n<script type=\"math/tex; mode=display\">M-1 = nC, n \\ge 1</script><p>这时候我们再设一个指针_head，初始为第一个节点的位置(head),那么此时slow(或者fast,因为循环终止条件是二者相同)与_head的距离为$nC$。此时再分两种情况讨论。</p>\n<ul>\n<li>如果第一次相遇的点就是head，那么说明head就是环的入口,直接返回head即可。这点很好理解。</li>\n<li>如果第一次相遇的不是head，,那么让_head和slow以相同速度前进，当_head到达环的入口时，因为slow和head的距离为$nC$，那么二者必然相遇。 因为对于_head而言，之前没有相遇的机会，所以第一次相遇的点必然是入口，返回_head即可。</li>\n</ul>\n<p>　　代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">detectCycle</span><span class=\"params\">(head)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type head: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> head:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">None</span></span><br><span class=\"line\">        slow, fast = head, head</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> fast <span class=\"keyword\">and</span> fast.next:</span><br><span class=\"line\">            slow = slow.next</span><br><span class=\"line\">            fast = fast.next.next</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> slow == fast:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> fast <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> fast.next:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">None</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> head == slow:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head</span><br><span class=\"line\">        _head = head</span><br><span class=\"line\">        <span class=\"keyword\">while</span> _head != slow:</span><br><span class=\"line\">            _head = _head.next</span><br><span class=\"line\">            slow = slow.next</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _head</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>　　刷完链表就刷树和图吧，数据结构太有意思了。记得之前我关注的一个博主曾在合理使用堆栈给出某道题很elegant的解法时感慨：“啊，这就是数据结构的胜利！！！”而我目前还只是在练习一些很简单的操作，希望我以后也能将它们变为趁手的利刃吧。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>　　今天记录的是两道特别有意思的题：判断链表中存不存在环(circle)。为了找解法，在纸上画了各种数字、箭头、圈圈和推导，还以为在研究什么彩票号码呢哈哈 ~ ~ ~</p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>　　和昨天一样，今天的两道题同样是分为基础版和进阶版，不同的是，今天的两个版本可以看作是一道大题的两小问，二者关联性更强。</p>\n<blockquote>\n<p>　　基础版：<br>　　<br>　　　　判断链表是否存在环。(<a href=\"https://leetcode.com/problems/linked-list-cycle/description//\" target=\"_blank\" rel=\"noopener\">141. Linked list cycle</a>)<br>　<br>　　进阶版：<br>　　<br>　　　　若存在环，找出环的起点。(<a href=\"https://leetcode.com/problems/linked-list-cycle-ii/description/\" target=\"_blank\" rel=\"noopener\">142. Linked list cycle II</a>)　　 　 　</p>\n</blockquote>\n<p>　　另外，要求在不修改链表的同时，空间复杂度为$O(1)$。</p>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h3 id=\"基础版\"><a href=\"#基础版\" class=\"headerlink\" title=\"基础版\"></a>基础版</h3><p>　　这道题我一开始是联想到了之前学习DFS的思路，即遍历每个节点，并在访问后做上visited的标记，如果访问到一个已经标记的节点，说明有环。然而想法是美好的，不，也并不美好，毕竟这个空间复杂度不是$O(1)$，而且发现没那么好实现，因为单向链表的特点就是不能回头，你很容易知道一个节点的下一个节点是啥，但前一个节点是啥？不能直接知道。</p>\n<p>　　后来逛了下别人的答案，感觉自己被羞辱了，思路完全不一样啊！完全没这么想啊！看来还是经验不够啊！(受打击三连)又学习到了。具体怎么做呢？需要用到两个指针，一个每次走一步(slow)，另一个走得快一点，每次走两步(fast)，咳咳，重点来了 ~ 如果一个链表不存在环，那总会走向终点(遇到Null)；如果存在环呢？那两个指针会一直走下去，但这样循环没法终止，就没法返回结果，所以进一步的判断依据是，如果存在环，slow和fast两个指针会相遇，一旦相遇，循环终止，即可返回结果。代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hasCycle</span><span class=\"params\">(head)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type head: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        slow, fast = head, head</span><br><span class=\"line\">        <span class=\"keyword\">while</span> fast <span class=\"keyword\">and</span> fast.next:</span><br><span class=\"line\">            slow = slow.next</span><br><span class=\"line\">            fast = fast.next.next</span><br><span class=\"line\">            <span class=\"keyword\">if</span> slow==fast:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"进阶版\"><a href=\"#进阶版\" class=\"headerlink\" title=\"进阶版\"></a>进阶版</h3><p>　　虽然有了基础版的打底，但进阶版也折腾了我很久，最后还是借了别人的智慧才解决的，唉，心塞。 和基础版一样，我们需要设置两个指针，均初始化为head(如果有的话)，因为没有环的情况很好判断，我们接下来只讨论在有环的情况下，如何找环的起始点。</p>\n<p>　　将head看作第一个节点，那么如果走$T-1$步的话，slow将会到达第$T$个节点，而fast会到达第$2T-1$个节点。当二者第一次相遇(meet)，设在第$M$个节点，那么slow和fast的距离为$M-1$个节点，那么$M-1$一定是环的节点个数(C)的整数倍，即：</p>\n<script type=\"math/tex; mode=display\">M-1 = nC, n \\ge 1</script><p>这时候我们再设一个指针_head，初始为第一个节点的位置(head),那么此时slow(或者fast,因为循环终止条件是二者相同)与_head的距离为$nC$。此时再分两种情况讨论。</p>\n<ul>\n<li>如果第一次相遇的点就是head，那么说明head就是环的入口,直接返回head即可。这点很好理解。</li>\n<li>如果第一次相遇的不是head，,那么让_head和slow以相同速度前进，当_head到达环的入口时，因为slow和head的距离为$nC$，那么二者必然相遇。 因为对于_head而言，之前没有相遇的机会，所以第一次相遇的点必然是入口，返回_head即可。</li>\n</ul>\n<p>　　代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">detectCycle</span><span class=\"params\">(head)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type head: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> head:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">None</span></span><br><span class=\"line\">        slow, fast = head, head</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> fast <span class=\"keyword\">and</span> fast.next:</span><br><span class=\"line\">            slow = slow.next</span><br><span class=\"line\">            fast = fast.next.next</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> slow == fast:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> fast <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> fast.next:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">None</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> head == slow:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head</span><br><span class=\"line\">        _head = head</span><br><span class=\"line\">        <span class=\"keyword\">while</span> _head != slow:</span><br><span class=\"line\">            _head = _head.next</span><br><span class=\"line\">            slow = slow.next</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _head</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>　　刷完链表就刷树和图吧，数据结构太有意思了。记得之前我关注的一个博主曾在合理使用堆栈给出某道题很elegant的解法时感慨：“啊，这就是数据结构的胜利！！！”而我目前还只是在练习一些很简单的操作，希望我以后也能将它们变为趁手的利刃吧。</p>\n"},{"title":"Gap Gap Gap","date":"2018-01-16T14:59:42.000Z","_content":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=32419802&auto=1&height=66\"></iframe>\n\n　　从博客搭建以来，每更新一篇都觉得压力重重：好像不能胡说，不能乱写，不能不严谨，不能不科学。直到昨天博客因为我的失误崩溃了，才意识到：这是我的个人blog，其实我可以写任何我想记录的事物，哪怕很感性，哪怕不够有格调。毕竟，本来就是为了好玩，为了“迹录”，何必给自己太多条条框框呢？\n\n　　庆幸的是，今天把博客抢修回来了。在修补的间隙，和上司长谈了一番，也是一时没忍住。虽然说出来并没有让我轻松多少，但也算是心平气和地收场。希望不后悔自己的决定，但愿在这之前我能为此努力。Gap Gap Gap year!\n\n　　总归是有舍才有得。其实这篇博客是为了测试添加音乐播放器的功能哈哈哈(所以这么言之无物),挑了首Por Una Cabeza (一步之遥)，不过因为版权保护，能生成外链播放的不多，这是我在不多的选择中挑出来比较好听的一个版本，听着能感受到tango的那种缠绵又对抗的挣扎感。\n\n\n","source":"_posts/Gap-Gap-Gap.md","raw":"---\ntitle: Gap Gap Gap\ndate: 2018-01-16 22:59:42\ntags:\n    - 随笔\n---\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=32419802&auto=1&height=66\"></iframe>\n\n　　从博客搭建以来，每更新一篇都觉得压力重重：好像不能胡说，不能乱写，不能不严谨，不能不科学。直到昨天博客因为我的失误崩溃了，才意识到：这是我的个人blog，其实我可以写任何我想记录的事物，哪怕很感性，哪怕不够有格调。毕竟，本来就是为了好玩，为了“迹录”，何必给自己太多条条框框呢？\n\n　　庆幸的是，今天把博客抢修回来了。在修补的间隙，和上司长谈了一番，也是一时没忍住。虽然说出来并没有让我轻松多少，但也算是心平气和地收场。希望不后悔自己的决定，但愿在这之前我能为此努力。Gap Gap Gap year!\n\n　　总归是有舍才有得。其实这篇博客是为了测试添加音乐播放器的功能哈哈哈(所以这么言之无物),挑了首Por Una Cabeza (一步之遥)，不过因为版权保护，能生成外链播放的不多，这是我在不多的选择中挑出来比较好听的一个版本，听着能感受到tango的那种缠绵又对抗的挣扎感。\n\n\n","slug":"Gap-Gap-Gap","published":1,"updated":"2018-01-16T15:34:46.219Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcknckyf0001souy0ehqy9gz","content":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=32419802&auto=1&height=66\"></iframe>\n\n<p>　　从博客搭建以来，每更新一篇都觉得压力重重：好像不能胡说，不能乱写，不能不严谨，不能不科学。直到昨天博客因为我的失误崩溃了，才意识到：这是我的个人blog，其实我可以写任何我想记录的事物，哪怕很感性，哪怕不够有格调。毕竟，本来就是为了好玩，为了“迹录”，何必给自己太多条条框框呢？</p>\n<p>　　庆幸的是，今天把博客抢修回来了。在修补的间隙，和上司长谈了一番，也是一时没忍住。虽然说出来并没有让我轻松多少，但也算是心平气和地收场。希望不后悔自己的决定，但愿在这之前我能为此努力。Gap Gap Gap year!</p>\n<p>　　总归是有舍才有得。其实这篇博客是为了测试添加音乐播放器的功能哈哈哈(所以这么言之无物),挑了首Por Una Cabeza (一步之遥)，不过因为版权保护，能生成外链播放的不多，这是我在不多的选择中挑出来比较好听的一个版本，听着能感受到tango的那种缠绵又对抗的挣扎感。</p>\n","site":{"data":{}},"excerpt":"","more":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=32419802&auto=1&height=66\"></iframe>\n\n<p>　　从博客搭建以来，每更新一篇都觉得压力重重：好像不能胡说，不能乱写，不能不严谨，不能不科学。直到昨天博客因为我的失误崩溃了，才意识到：这是我的个人blog，其实我可以写任何我想记录的事物，哪怕很感性，哪怕不够有格调。毕竟，本来就是为了好玩，为了“迹录”，何必给自己太多条条框框呢？</p>\n<p>　　庆幸的是，今天把博客抢修回来了。在修补的间隙，和上司长谈了一番，也是一时没忍住。虽然说出来并没有让我轻松多少，但也算是心平气和地收场。希望不后悔自己的决定，但愿在这之前我能为此努力。Gap Gap Gap year!</p>\n<p>　　总归是有舍才有得。其实这篇博客是为了测试添加音乐播放器的功能哈哈哈(所以这么言之无物),挑了首Por Una Cabeza (一步之遥)，不过因为版权保护，能生成外链播放的不多，这是我在不多的选择中挑出来比较好听的一个版本，听着能感受到tango的那种缠绵又对抗的挣扎感。</p>\n"},{"title":"Leetcode之旅|Brainy is the new sexy","date":"2017-09-20T14:25:20.000Z","_content":"---\n\n   做这道题的时候一直在想《神探夏洛克》的S02E01，因为想到最开始学到快速排序的时候的惊艳感：人的智商真的就可以这么简单粗暴地展现出来。然后脑子里一直是当时卷福破解Irene手机密码的那段台词,根本停不下来：\n\nSentiment is the chemical defect found in the losing side.\nDisguise is a self-portrait.\nI imagine John Watson thinks that love is a mystery to me, but the chemistry is incredibly simple and very destructive. Thank you for the final proof.\n\n啊啦啦，不能再叨叨这段台词了，不然忍不住要看。反正也是听着这段音乐答的题~~~\n\n## 问题描述\n---\n75 Sort colors\n\nGiven an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.\n\nHere, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.\n\nNote:\nYou are not suppose to use the library's sort function for this problem.\n\n## 思路\n---\n   看到这个问题的时候，首先想到的是最近看的快速排序算法的实现过程，因为感觉惊为天人，并意识到为啥之前斯坦福那个老师说算法让人smart,因为感觉不smart怎么能想出这么惊艳的算法（反正我是无论如何也想不出来的。。。）。\n\n   简而言之，我理解的快速排序就是选择一个主元x（最基本的版本里一般就是最后一个元素），然后对序列里所有元素进行扫描，并用一个指针记录i目前比x小的数（这里假设是要实现升序排列），即i总是指向最新找到的比x小的数，因为每扫描到一个比x小的数，都会将其与i当前指向的数的后一个数交换（因为i指向的是最新的比x小的数，所以它后一位肯定比x大），并将i后移一位，最后将序列划分了两堆，比x大的都在一边，比x小的都在另一边。然后再运用divide and conquer的方法，就能实现在O(nlgn)的时间内对序列进行原址排序。\n \n<!-- more -->\n   为什么做这道题的时候想到了快速排序呢，就是觉得思路是一样的。不同的是，这里我们要提供两个指针，一个指向目前所有发现的0的下一位，一个指向目前发现的1的下一位。然后我们就可以这么操作：\n   - 两个指针p0，p1都初始化为0，对数组进行扫描；\n   - 如果发现数是0，那么，0的个数要加1，因为0排在最前面，牵一发而动全身，p0要不指向的是当前数，要不指向的就是拍在它后面的1,所以p0当前指向的数变成0后，p1指向的数就应该与p0指向的数进行交换，而目前扫描到的数又应该和p1指向的数进行交换。这和快速排序交换元素的思路其实是一样的：我们并不关心交换哪两个具体的元素，只关心交换的哪两类的具体元素，因为我们对每类元素的具体细节没有要求，而只对它们整体的共性有要求。对快速排序而言，这个共性是比x大或者小这两种情况，而不需要关心它们之间具体谁大谁小；而对这个题目而言则是0，1，2这三类。然后两个指针皆往后移一位；\n   - 如果发现数是1则更更简单，只需要将当前指针指向的数变成p1指向的数交换，而p1指向的数变成1即可；\n   - 如果发现数是2，则不需要进行任何变化。\n\n\n   这么说了之后，代码就很容易实现了：\n\n\n```python\ndef sortColors(nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        p0=p1=0\n        for p in range(len(nums)):\n            value = nums[p]\n            if value==0:\n                nums[p] = nums[p1]\n                nums[p1] = nums[p0]\n                nums[p0] = 0\n                p0+=1\n                p1+=1\n            if value==1:\n                nums[p]=nums[p1]\n                nums[p1] = 1\n                p1+=1\n        print(nums)\n```\n\n我们测试一下：\n\n\n```python\nsortColors([1,0,2,1,0,1,2,0,2,1,2])\n```\n\n    [0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2]\n\n\n## 进一步简化代码\n---\n由上述代码我们可以看到，其实当扫描到0或者1之后，其实有些操作是一样的，比如p1都会后移一位，而p1指向的数都会改变：变成1或者p0当前指向的数，且p0当前指向的数只有两种可能：当前扫描到的数或者其实就是1。同理，p1当前指向的数也只有两种可能：当前扫描到的数或者2。基于这些事实，我们可以对代码进行简化：\n- 把扫描到当前位置的值设为2；\n- 如果当前位置的实际值小于2（即0或者1），那p1肯定是要后移一位，且p1当前指向的数可能变为1，因为如果是0，所以1到往后挪一位，那p1指向1；如果是1，那1的个数加1，当前指向值也只能是1；\n- 如果当前位置的实际值为0，那把p0指向的值变为0即可，然后p0后移一位；\n- 如果是2那再好不过，我们已经在第一步处理好了。\n\n\n```python\ndef sortColors1(nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        p0=p1=0\n        for p in range(len(nums)):\n            value = nums[p]\n            nums[p] = 2\n            if value<2:\n                nums[p1] = 1\n                p1+=1\n            if value==0:\n                nums[p0]=0\n                p0+=1\n        print(nums)\n```\n\n测试同样通过：\n\n\n```python\nsortColors1([1,0,2,1,0,1,2,0,2,1,2,0,1,0,2])\n```\n\n    [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2]","source":"_posts/Brainy-is-the-new-sexy.md","raw":"---\ntitle: Leetcode之旅|Brainy is the new sexy\ndate: 2017-09-20 22:25:20\ntags:\n    - Leetcode\n    - algorithm\n    - 随笔 \ncategories:\n    - Leetcode\n\n---\n---\n\n   做这道题的时候一直在想《神探夏洛克》的S02E01，因为想到最开始学到快速排序的时候的惊艳感：人的智商真的就可以这么简单粗暴地展现出来。然后脑子里一直是当时卷福破解Irene手机密码的那段台词,根本停不下来：\n\nSentiment is the chemical defect found in the losing side.\nDisguise is a self-portrait.\nI imagine John Watson thinks that love is a mystery to me, but the chemistry is incredibly simple and very destructive. Thank you for the final proof.\n\n啊啦啦，不能再叨叨这段台词了，不然忍不住要看。反正也是听着这段音乐答的题~~~\n\n## 问题描述\n---\n75 Sort colors\n\nGiven an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.\n\nHere, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.\n\nNote:\nYou are not suppose to use the library's sort function for this problem.\n\n## 思路\n---\n   看到这个问题的时候，首先想到的是最近看的快速排序算法的实现过程，因为感觉惊为天人，并意识到为啥之前斯坦福那个老师说算法让人smart,因为感觉不smart怎么能想出这么惊艳的算法（反正我是无论如何也想不出来的。。。）。\n\n   简而言之，我理解的快速排序就是选择一个主元x（最基本的版本里一般就是最后一个元素），然后对序列里所有元素进行扫描，并用一个指针记录i目前比x小的数（这里假设是要实现升序排列），即i总是指向最新找到的比x小的数，因为每扫描到一个比x小的数，都会将其与i当前指向的数的后一个数交换（因为i指向的是最新的比x小的数，所以它后一位肯定比x大），并将i后移一位，最后将序列划分了两堆，比x大的都在一边，比x小的都在另一边。然后再运用divide and conquer的方法，就能实现在O(nlgn)的时间内对序列进行原址排序。\n \n<!-- more -->\n   为什么做这道题的时候想到了快速排序呢，就是觉得思路是一样的。不同的是，这里我们要提供两个指针，一个指向目前所有发现的0的下一位，一个指向目前发现的1的下一位。然后我们就可以这么操作：\n   - 两个指针p0，p1都初始化为0，对数组进行扫描；\n   - 如果发现数是0，那么，0的个数要加1，因为0排在最前面，牵一发而动全身，p0要不指向的是当前数，要不指向的就是拍在它后面的1,所以p0当前指向的数变成0后，p1指向的数就应该与p0指向的数进行交换，而目前扫描到的数又应该和p1指向的数进行交换。这和快速排序交换元素的思路其实是一样的：我们并不关心交换哪两个具体的元素，只关心交换的哪两类的具体元素，因为我们对每类元素的具体细节没有要求，而只对它们整体的共性有要求。对快速排序而言，这个共性是比x大或者小这两种情况，而不需要关心它们之间具体谁大谁小；而对这个题目而言则是0，1，2这三类。然后两个指针皆往后移一位；\n   - 如果发现数是1则更更简单，只需要将当前指针指向的数变成p1指向的数交换，而p1指向的数变成1即可；\n   - 如果发现数是2，则不需要进行任何变化。\n\n\n   这么说了之后，代码就很容易实现了：\n\n\n```python\ndef sortColors(nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        p0=p1=0\n        for p in range(len(nums)):\n            value = nums[p]\n            if value==0:\n                nums[p] = nums[p1]\n                nums[p1] = nums[p0]\n                nums[p0] = 0\n                p0+=1\n                p1+=1\n            if value==1:\n                nums[p]=nums[p1]\n                nums[p1] = 1\n                p1+=1\n        print(nums)\n```\n\n我们测试一下：\n\n\n```python\nsortColors([1,0,2,1,0,1,2,0,2,1,2])\n```\n\n    [0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2]\n\n\n## 进一步简化代码\n---\n由上述代码我们可以看到，其实当扫描到0或者1之后，其实有些操作是一样的，比如p1都会后移一位，而p1指向的数都会改变：变成1或者p0当前指向的数，且p0当前指向的数只有两种可能：当前扫描到的数或者其实就是1。同理，p1当前指向的数也只有两种可能：当前扫描到的数或者2。基于这些事实，我们可以对代码进行简化：\n- 把扫描到当前位置的值设为2；\n- 如果当前位置的实际值小于2（即0或者1），那p1肯定是要后移一位，且p1当前指向的数可能变为1，因为如果是0，所以1到往后挪一位，那p1指向1；如果是1，那1的个数加1，当前指向值也只能是1；\n- 如果当前位置的实际值为0，那把p0指向的值变为0即可，然后p0后移一位；\n- 如果是2那再好不过，我们已经在第一步处理好了。\n\n\n```python\ndef sortColors1(nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        p0=p1=0\n        for p in range(len(nums)):\n            value = nums[p]\n            nums[p] = 2\n            if value<2:\n                nums[p1] = 1\n                p1+=1\n            if value==0:\n                nums[p0]=0\n                p0+=1\n        print(nums)\n```\n\n测试同样通过：\n\n\n```python\nsortColors1([1,0,2,1,0,1,2,0,2,1,2,0,1,0,2])\n```\n\n    [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2]","slug":"Brainy-is-the-new-sexy","published":1,"updated":"2018-01-17T14:07:02.164Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcknckyf0003souyjhj4l3wr","content":"<hr>\n<p>   做这道题的时候一直在想《神探夏洛克》的S02E01，因为想到最开始学到快速排序的时候的惊艳感：人的智商真的就可以这么简单粗暴地展现出来。然后脑子里一直是当时卷福破解Irene手机密码的那段台词,根本停不下来：</p>\n<p>Sentiment is the chemical defect found in the losing side.<br>Disguise is a self-portrait.<br>I imagine John Watson thinks that love is a mystery to me, but the chemistry is incredibly simple and very destructive. Thank you for the final proof.</p>\n<p>啊啦啦，不能再叨叨这段台词了，不然忍不住要看。反正也是听着这段音乐答的题~~~</p>\n<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><hr>\n<p>75 Sort colors</p>\n<p>Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p>\n<p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>\n<p>Note:<br>You are not suppose to use the library’s sort function for this problem.</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><hr>\n<p>   看到这个问题的时候，首先想到的是最近看的快速排序算法的实现过程，因为感觉惊为天人，并意识到为啥之前斯坦福那个老师说算法让人smart,因为感觉不smart怎么能想出这么惊艳的算法（反正我是无论如何也想不出来的。。。）。</p>\n<p>   简而言之，我理解的快速排序就是选择一个主元x（最基本的版本里一般就是最后一个元素），然后对序列里所有元素进行扫描，并用一个指针记录i目前比x小的数（这里假设是要实现升序排列），即i总是指向最新找到的比x小的数，因为每扫描到一个比x小的数，都会将其与i当前指向的数的后一个数交换（因为i指向的是最新的比x小的数，所以它后一位肯定比x大），并将i后移一位，最后将序列划分了两堆，比x大的都在一边，比x小的都在另一边。然后再运用divide and conquer的方法，就能实现在O(nlgn)的时间内对序列进行原址排序。</p>\n<a id=\"more\"></a>\n<p>   为什么做这道题的时候想到了快速排序呢，就是觉得思路是一样的。不同的是，这里我们要提供两个指针，一个指向目前所有发现的0的下一位，一个指向目前发现的1的下一位。然后我们就可以这么操作：</p>\n<ul>\n<li>两个指针p0，p1都初始化为0，对数组进行扫描；</li>\n<li>如果发现数是0，那么，0的个数要加1，因为0排在最前面，牵一发而动全身，p0要不指向的是当前数，要不指向的就是拍在它后面的1,所以p0当前指向的数变成0后，p1指向的数就应该与p0指向的数进行交换，而目前扫描到的数又应该和p1指向的数进行交换。这和快速排序交换元素的思路其实是一样的：我们并不关心交换哪两个具体的元素，只关心交换的哪两类的具体元素，因为我们对每类元素的具体细节没有要求，而只对它们整体的共性有要求。对快速排序而言，这个共性是比x大或者小这两种情况，而不需要关心它们之间具体谁大谁小；而对这个题目而言则是0，1，2这三类。然后两个指针皆往后移一位；</li>\n<li>如果发现数是1则更更简单，只需要将当前指针指向的数变成p1指向的数交换，而p1指向的数变成1即可；</li>\n<li>如果发现数是2，则不需要进行任何变化。</li>\n</ul>\n<p>   这么说了之后，代码就很容易实现了：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sortColors</span><span class=\"params\">(nums)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        p0=p1=<span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> range(len(nums)):</span><br><span class=\"line\">            value = nums[p]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> value==<span class=\"number\">0</span>:</span><br><span class=\"line\">                nums[p] = nums[p1]</span><br><span class=\"line\">                nums[p1] = nums[p0]</span><br><span class=\"line\">                nums[p0] = <span class=\"number\">0</span></span><br><span class=\"line\">                p0+=<span class=\"number\">1</span></span><br><span class=\"line\">                p1+=<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> value==<span class=\"number\">1</span>:</span><br><span class=\"line\">                nums[p]=nums[p1]</span><br><span class=\"line\">                nums[p1] = <span class=\"number\">1</span></span><br><span class=\"line\">                p1+=<span class=\"number\">1</span></span><br><span class=\"line\">        print(nums)</span><br></pre></td></tr></table></figure>\n<p>我们测试一下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sortColors([<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>])</span><br></pre></td></tr></table></figure>\n<pre><code>[0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2]\n</code></pre><h2 id=\"进一步简化代码\"><a href=\"#进一步简化代码\" class=\"headerlink\" title=\"进一步简化代码\"></a>进一步简化代码</h2><hr>\n<p>由上述代码我们可以看到，其实当扫描到0或者1之后，其实有些操作是一样的，比如p1都会后移一位，而p1指向的数都会改变：变成1或者p0当前指向的数，且p0当前指向的数只有两种可能：当前扫描到的数或者其实就是1。同理，p1当前指向的数也只有两种可能：当前扫描到的数或者2。基于这些事实，我们可以对代码进行简化：</p>\n<ul>\n<li>把扫描到当前位置的值设为2；</li>\n<li>如果当前位置的实际值小于2（即0或者1），那p1肯定是要后移一位，且p1当前指向的数可能变为1，因为如果是0，所以1到往后挪一位，那p1指向1；如果是1，那1的个数加1，当前指向值也只能是1；</li>\n<li>如果当前位置的实际值为0，那把p0指向的值变为0即可，然后p0后移一位；</li>\n<li>如果是2那再好不过，我们已经在第一步处理好了。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sortColors1</span><span class=\"params\">(nums)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        p0=p1=<span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> range(len(nums)):</span><br><span class=\"line\">            value = nums[p]</span><br><span class=\"line\">            nums[p] = <span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> value&lt;<span class=\"number\">2</span>:</span><br><span class=\"line\">                nums[p1] = <span class=\"number\">1</span></span><br><span class=\"line\">                p1+=<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> value==<span class=\"number\">0</span>:</span><br><span class=\"line\">                nums[p0]=<span class=\"number\">0</span></span><br><span class=\"line\">                p0+=<span class=\"number\">1</span></span><br><span class=\"line\">        print(nums)</span><br></pre></td></tr></table></figure>\n<p>测试同样通过：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sortColors1([<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>])</span><br></pre></td></tr></table></figure>\n<pre><code>[0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2]\n</code></pre>","site":{"data":{}},"excerpt":"<hr>\n<p>   做这道题的时候一直在想《神探夏洛克》的S02E01，因为想到最开始学到快速排序的时候的惊艳感：人的智商真的就可以这么简单粗暴地展现出来。然后脑子里一直是当时卷福破解Irene手机密码的那段台词,根本停不下来：</p>\n<p>Sentiment is the chemical defect found in the losing side.<br>Disguise is a self-portrait.<br>I imagine John Watson thinks that love is a mystery to me, but the chemistry is incredibly simple and very destructive. Thank you for the final proof.</p>\n<p>啊啦啦，不能再叨叨这段台词了，不然忍不住要看。反正也是听着这段音乐答的题~~~</p>\n<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><hr>\n<p>75 Sort colors</p>\n<p>Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p>\n<p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>\n<p>Note:<br>You are not suppose to use the library’s sort function for this problem.</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><hr>\n<p>   看到这个问题的时候，首先想到的是最近看的快速排序算法的实现过程，因为感觉惊为天人，并意识到为啥之前斯坦福那个老师说算法让人smart,因为感觉不smart怎么能想出这么惊艳的算法（反正我是无论如何也想不出来的。。。）。</p>\n<p>   简而言之，我理解的快速排序就是选择一个主元x（最基本的版本里一般就是最后一个元素），然后对序列里所有元素进行扫描，并用一个指针记录i目前比x小的数（这里假设是要实现升序排列），即i总是指向最新找到的比x小的数，因为每扫描到一个比x小的数，都会将其与i当前指向的数的后一个数交换（因为i指向的是最新的比x小的数，所以它后一位肯定比x大），并将i后移一位，最后将序列划分了两堆，比x大的都在一边，比x小的都在另一边。然后再运用divide and conquer的方法，就能实现在O(nlgn)的时间内对序列进行原址排序。</p>","more":"<p>   为什么做这道题的时候想到了快速排序呢，就是觉得思路是一样的。不同的是，这里我们要提供两个指针，一个指向目前所有发现的0的下一位，一个指向目前发现的1的下一位。然后我们就可以这么操作：</p>\n<ul>\n<li>两个指针p0，p1都初始化为0，对数组进行扫描；</li>\n<li>如果发现数是0，那么，0的个数要加1，因为0排在最前面，牵一发而动全身，p0要不指向的是当前数，要不指向的就是拍在它后面的1,所以p0当前指向的数变成0后，p1指向的数就应该与p0指向的数进行交换，而目前扫描到的数又应该和p1指向的数进行交换。这和快速排序交换元素的思路其实是一样的：我们并不关心交换哪两个具体的元素，只关心交换的哪两类的具体元素，因为我们对每类元素的具体细节没有要求，而只对它们整体的共性有要求。对快速排序而言，这个共性是比x大或者小这两种情况，而不需要关心它们之间具体谁大谁小；而对这个题目而言则是0，1，2这三类。然后两个指针皆往后移一位；</li>\n<li>如果发现数是1则更更简单，只需要将当前指针指向的数变成p1指向的数交换，而p1指向的数变成1即可；</li>\n<li>如果发现数是2，则不需要进行任何变化。</li>\n</ul>\n<p>   这么说了之后，代码就很容易实现了：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sortColors</span><span class=\"params\">(nums)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        p0=p1=<span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> range(len(nums)):</span><br><span class=\"line\">            value = nums[p]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> value==<span class=\"number\">0</span>:</span><br><span class=\"line\">                nums[p] = nums[p1]</span><br><span class=\"line\">                nums[p1] = nums[p0]</span><br><span class=\"line\">                nums[p0] = <span class=\"number\">0</span></span><br><span class=\"line\">                p0+=<span class=\"number\">1</span></span><br><span class=\"line\">                p1+=<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> value==<span class=\"number\">1</span>:</span><br><span class=\"line\">                nums[p]=nums[p1]</span><br><span class=\"line\">                nums[p1] = <span class=\"number\">1</span></span><br><span class=\"line\">                p1+=<span class=\"number\">1</span></span><br><span class=\"line\">        print(nums)</span><br></pre></td></tr></table></figure>\n<p>我们测试一下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sortColors([<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>])</span><br></pre></td></tr></table></figure>\n<pre><code>[0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2]\n</code></pre><h2 id=\"进一步简化代码\"><a href=\"#进一步简化代码\" class=\"headerlink\" title=\"进一步简化代码\"></a>进一步简化代码</h2><hr>\n<p>由上述代码我们可以看到，其实当扫描到0或者1之后，其实有些操作是一样的，比如p1都会后移一位，而p1指向的数都会改变：变成1或者p0当前指向的数，且p0当前指向的数只有两种可能：当前扫描到的数或者其实就是1。同理，p1当前指向的数也只有两种可能：当前扫描到的数或者2。基于这些事实，我们可以对代码进行简化：</p>\n<ul>\n<li>把扫描到当前位置的值设为2；</li>\n<li>如果当前位置的实际值小于2（即0或者1），那p1肯定是要后移一位，且p1当前指向的数可能变为1，因为如果是0，所以1到往后挪一位，那p1指向1；如果是1，那1的个数加1，当前指向值也只能是1；</li>\n<li>如果当前位置的实际值为0，那把p0指向的值变为0即可，然后p0后移一位；</li>\n<li>如果是2那再好不过，我们已经在第一步处理好了。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sortColors1</span><span class=\"params\">(nums)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        p0=p1=<span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> range(len(nums)):</span><br><span class=\"line\">            value = nums[p]</span><br><span class=\"line\">            nums[p] = <span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> value&lt;<span class=\"number\">2</span>:</span><br><span class=\"line\">                nums[p1] = <span class=\"number\">1</span></span><br><span class=\"line\">                p1+=<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> value==<span class=\"number\">0</span>:</span><br><span class=\"line\">                nums[p0]=<span class=\"number\">0</span></span><br><span class=\"line\">                p0+=<span class=\"number\">1</span></span><br><span class=\"line\">        print(nums)</span><br></pre></td></tr></table></figure>\n<p>测试同样通过：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sortColors1([<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>])</span><br></pre></td></tr></table></figure>\n<pre><code>[0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2]\n</code></pre>"},{"title":"Leetcode之旅|链表啊，链表！(1)","date":"2018-01-17T14:12:23.000Z","mathjax":true,"_content":"　　自从前两天刷了那道链表的题之后觉得很有意思，奇妙的数据结构哇咔咔 ~ ~ ~ 但毕竟不是科班出身，对它的一些操作非常不熟悉，每次被各种head,tail,pre,next指来指去的东西绕得晕头转向。嗯，熟能生巧，所以我最近专注于刷链表相关的题目啊哈哈 ~ ~ ~\n\n## 题目描述\n\n　　这篇博客回顾的题目是删除链表中重复元素的问题（链表均已排好序）：\n\n　　基础版：只删除重复了的元素，即保证唯一性 （[Leetcode Problem 83](https://leetcode.com/problems/remove-duplicates-from-sorted-list/) ）。\n\n　　进阶版：删除有重复出现过的元素，即如果元素重复了，就将其从链表中剔除 （[Leetcode Problem 82](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii) ）。\n\n　　发现我的语言很苍白，还是看实例吧：\n\n　　基础包：\n\n```python\nGiven 1->2->3->3->4->4->5, return 1->2->5.\nGiven 1->1->1->2->3, return 2->3.\n```\n\n　　升级包：\n\n```python\nGiven 1->2->3->3->4->4->5, return 1->2->5.\nGiven 1->1->1->2->3, return 2->3.\n```\n\n## 解题思路及相关代码\n\n### 基础版\n\n　　对于基础包而言，我们只需要一个指针，即下面代码中的cur，从head开始挨个遍历链表节点（所以链表已经排序好这个前提很重要），对于每个cur，将其与其后继的节点值比较，如果相同，说明这个后继需要删除，对链表而言，操作则相当简单，直接将cur的后继改为当前后继的后继即可。如果不同，说明没有与当前节点值重复的了，直接将当前节点后移即可，即将cur更新为当前节点的后继。\n　　代码如下：\n\n\n```python\ndef deleteDuplicates(head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        # 链表为空的特殊情况\n        if not head:\n            return head\n        # 当前节点初始化为表头\n        cur = head\n        \n        # 遍历，循环条件为当前节点和当前节点的后继不为空\n        while cur and cur.next:\n            # 如果当前节点值和其后继值相等，则将其后继改为后继的后继\n            if cur.val == cur.next.val:\n                cur.next = cur.next.next\n            # 如果不相等，则将当前节点更新\n            else:\n                cur = cur.next\n        return head\n```\n\n <!-- more -->\n\n \n### 进阶版\n\n　　和基础版相比，进阶版的难度体现在两个方面：第一，因为重复出现过的元素需要删除，所以表头可能会被修改（如第一次出现的元素就重复的情况）；第二，因为重复出现过的元素很随机，所以一个指针不够提供足够的信息，比如上述例子中的第一个，在将3和4删除后，得知道5的前驱是2。\n　　对此，我的解决方案是：\n　　１.　使用两个指针，一个用来指代当前节点(cur)，初始化为表头，另一个为前驱节点(pre)，可以在删除重复节点后，给下一个节点提供前驱信息，初始化为Null。\n　　2.　从当前节点开始遍历链表，从简单的情况开始处理，即如果当前值不等于其后继值，那么非常lucky，这个节点不重复了，将前驱节点更新为当前节点，将当前节点更新为其后继节点，然后跳出本次循环，move on；\n　　3.　如果相等呢？那我们就得顺着往下捋,即更新后继节点_next，直到不相等了，这时_next指向的是第一个不与前面节点重复的节点，而cur指向的是这批重复节点的第一个节点。那么这时要删除的话就有两种情况了:第一，如果重复段在表头，说明head要更新，更新为_next节点了，这时pre依旧指向Null，然后将cur更新为_next；第二，如果这批重复的是中间的批次，说明head不用更新了，但因为中间这批重复的全删了，所以pre的后继得更新为_next，和第一种情况一样，cur也要后移，即更新为_next。\n　　代码如下：\n\n\n```python\ndef deleteDuplicates(head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return head\n        \n        # 两个指针：pre和cur\n        pre = None\n        cur = head\n        \n        # 遍历所有节点\n        while cur:\n            # 一个临时指针指向cur的后继\n            _next = cur.next\n            \n            if not _next:\n                return head\n            \n            # 如果两个值不相等，则将pre和cur都往后移\n            elif cur.val != _next.val:\n                pre = cur\n                cur = _next\n                continue\n            \n            # 如果相等，则将_next一直捋到不重复为止\n            else:\n                while _next and _next.val == cur.val:\n                    _next = _next.next\n                \n                # 如果重复段在表头，则需要更新表头信息\n                if cur == head:\n                    head = _next\n                # 如果重复段在中间，则需要将pre的后继更新为_next\n                else:\n                    pre.next = _next\n                # 继续遍历\n                cur = _next\n        return head\n```\n\n## 结果\n\n　　测试：均已通过\n\n## 思考：\n\n　　１.　基础版是用迭代法，“凡是迭代即可递归”，试试递归如何实现？\n　　2.　进阶版是最优化的吗？可以逛逛discuss看是否还可进一步优化？","source":"_posts/Leetcode之旅-链表啊，链表！.md","raw":"---\ntitle: Leetcode之旅|链表啊，链表！(1)\ndate: 2018-01-17 22:12:23\ntags:\n    - Leetcode\n    - Data Structure\n    - 随笔\nmathjax: true\n---\n　　自从前两天刷了那道链表的题之后觉得很有意思，奇妙的数据结构哇咔咔 ~ ~ ~ 但毕竟不是科班出身，对它的一些操作非常不熟悉，每次被各种head,tail,pre,next指来指去的东西绕得晕头转向。嗯，熟能生巧，所以我最近专注于刷链表相关的题目啊哈哈 ~ ~ ~\n\n## 题目描述\n\n　　这篇博客回顾的题目是删除链表中重复元素的问题（链表均已排好序）：\n\n　　基础版：只删除重复了的元素，即保证唯一性 （[Leetcode Problem 83](https://leetcode.com/problems/remove-duplicates-from-sorted-list/) ）。\n\n　　进阶版：删除有重复出现过的元素，即如果元素重复了，就将其从链表中剔除 （[Leetcode Problem 82](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii) ）。\n\n　　发现我的语言很苍白，还是看实例吧：\n\n　　基础包：\n\n```python\nGiven 1->2->3->3->4->4->5, return 1->2->5.\nGiven 1->1->1->2->3, return 2->3.\n```\n\n　　升级包：\n\n```python\nGiven 1->2->3->3->4->4->5, return 1->2->5.\nGiven 1->1->1->2->3, return 2->3.\n```\n\n## 解题思路及相关代码\n\n### 基础版\n\n　　对于基础包而言，我们只需要一个指针，即下面代码中的cur，从head开始挨个遍历链表节点（所以链表已经排序好这个前提很重要），对于每个cur，将其与其后继的节点值比较，如果相同，说明这个后继需要删除，对链表而言，操作则相当简单，直接将cur的后继改为当前后继的后继即可。如果不同，说明没有与当前节点值重复的了，直接将当前节点后移即可，即将cur更新为当前节点的后继。\n　　代码如下：\n\n\n```python\ndef deleteDuplicates(head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        # 链表为空的特殊情况\n        if not head:\n            return head\n        # 当前节点初始化为表头\n        cur = head\n        \n        # 遍历，循环条件为当前节点和当前节点的后继不为空\n        while cur and cur.next:\n            # 如果当前节点值和其后继值相等，则将其后继改为后继的后继\n            if cur.val == cur.next.val:\n                cur.next = cur.next.next\n            # 如果不相等，则将当前节点更新\n            else:\n                cur = cur.next\n        return head\n```\n\n <!-- more -->\n\n \n### 进阶版\n\n　　和基础版相比，进阶版的难度体现在两个方面：第一，因为重复出现过的元素需要删除，所以表头可能会被修改（如第一次出现的元素就重复的情况）；第二，因为重复出现过的元素很随机，所以一个指针不够提供足够的信息，比如上述例子中的第一个，在将3和4删除后，得知道5的前驱是2。\n　　对此，我的解决方案是：\n　　１.　使用两个指针，一个用来指代当前节点(cur)，初始化为表头，另一个为前驱节点(pre)，可以在删除重复节点后，给下一个节点提供前驱信息，初始化为Null。\n　　2.　从当前节点开始遍历链表，从简单的情况开始处理，即如果当前值不等于其后继值，那么非常lucky，这个节点不重复了，将前驱节点更新为当前节点，将当前节点更新为其后继节点，然后跳出本次循环，move on；\n　　3.　如果相等呢？那我们就得顺着往下捋,即更新后继节点_next，直到不相等了，这时_next指向的是第一个不与前面节点重复的节点，而cur指向的是这批重复节点的第一个节点。那么这时要删除的话就有两种情况了:第一，如果重复段在表头，说明head要更新，更新为_next节点了，这时pre依旧指向Null，然后将cur更新为_next；第二，如果这批重复的是中间的批次，说明head不用更新了，但因为中间这批重复的全删了，所以pre的后继得更新为_next，和第一种情况一样，cur也要后移，即更新为_next。\n　　代码如下：\n\n\n```python\ndef deleteDuplicates(head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return head\n        \n        # 两个指针：pre和cur\n        pre = None\n        cur = head\n        \n        # 遍历所有节点\n        while cur:\n            # 一个临时指针指向cur的后继\n            _next = cur.next\n            \n            if not _next:\n                return head\n            \n            # 如果两个值不相等，则将pre和cur都往后移\n            elif cur.val != _next.val:\n                pre = cur\n                cur = _next\n                continue\n            \n            # 如果相等，则将_next一直捋到不重复为止\n            else:\n                while _next and _next.val == cur.val:\n                    _next = _next.next\n                \n                # 如果重复段在表头，则需要更新表头信息\n                if cur == head:\n                    head = _next\n                # 如果重复段在中间，则需要将pre的后继更新为_next\n                else:\n                    pre.next = _next\n                # 继续遍历\n                cur = _next\n        return head\n```\n\n## 结果\n\n　　测试：均已通过\n\n## 思考：\n\n　　１.　基础版是用迭代法，“凡是迭代即可递归”，试试递归如何实现？\n　　2.　进阶版是最优化的吗？可以逛逛discuss看是否还可进一步优化？","slug":"Leetcode之旅-链表啊，链表！","published":1,"updated":"2018-01-17T15:46:52.570Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcknckyf0004souyktlpnmsf","content":"<p>　　自从前两天刷了那道链表的题之后觉得很有意思，奇妙的数据结构哇咔咔 ~ ~ ~ 但毕竟不是科班出身，对它的一些操作非常不熟悉，每次被各种head,tail,pre,next指来指去的东西绕得晕头转向。嗯，熟能生巧，所以我最近专注于刷链表相关的题目啊哈哈 ~ ~ ~</p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>　　这篇博客回顾的题目是删除链表中重复元素的问题（链表均已排好序）：</p>\n<p>　　基础版：只删除重复了的元素，即保证唯一性 （<a href=\"https://leetcode.com/problems/remove-duplicates-from-sorted-list/\" target=\"_blank\" rel=\"noopener\">Leetcode Problem 83</a> ）。</p>\n<p>　　进阶版：删除有重复出现过的元素，即如果元素重复了，就将其从链表中剔除 （<a href=\"https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii\" target=\"_blank\" rel=\"noopener\">Leetcode Problem 82</a> ）。</p>\n<p>　　发现我的语言很苍白，还是看实例吧：</p>\n<p>　　基础包：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.</span><br><span class=\"line\">Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3.</span><br></pre></td></tr></table></figure>\n<p>　　升级包：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.</span><br><span class=\"line\">Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3.</span><br></pre></td></tr></table></figure>\n<h2 id=\"解题思路及相关代码\"><a href=\"#解题思路及相关代码\" class=\"headerlink\" title=\"解题思路及相关代码\"></a>解题思路及相关代码</h2><h3 id=\"基础版\"><a href=\"#基础版\" class=\"headerlink\" title=\"基础版\"></a>基础版</h3><p>　　对于基础包而言，我们只需要一个指针，即下面代码中的cur，从head开始挨个遍历链表节点（所以链表已经排序好这个前提很重要），对于每个cur，将其与其后继的节点值比较，如果相同，说明这个后继需要删除，对链表而言，操作则相当简单，直接将cur的后继改为当前后继的后继即可。如果不同，说明没有与当前节点值重复的了，直接将当前节点后移即可，即将cur更新为当前节点的后继。<br>　　代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">deleteDuplicates</span><span class=\"params\">(head)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type head: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"comment\"># 链表为空的特殊情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> head:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head</span><br><span class=\"line\">        <span class=\"comment\"># 当前节点初始化为表头</span></span><br><span class=\"line\">        cur = head</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 遍历，循环条件为当前节点和当前节点的后继不为空</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> cur <span class=\"keyword\">and</span> cur.next:</span><br><span class=\"line\">            <span class=\"comment\"># 如果当前节点值和其后继值相等，则将其后继改为后继的后继</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> cur.val == cur.next.val:</span><br><span class=\"line\">                cur.next = cur.next.next</span><br><span class=\"line\">            <span class=\"comment\"># 如果不相等，则将当前节点更新</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                cur = cur.next</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head</span><br></pre></td></tr></table></figure>\n <a id=\"more\"></a>\n<h3 id=\"进阶版\"><a href=\"#进阶版\" class=\"headerlink\" title=\"进阶版\"></a>进阶版</h3><p>　　和基础版相比，进阶版的难度体现在两个方面：第一，因为重复出现过的元素需要删除，所以表头可能会被修改（如第一次出现的元素就重复的情况）；第二，因为重复出现过的元素很随机，所以一个指针不够提供足够的信息，比如上述例子中的第一个，在将3和4删除后，得知道5的前驱是2。<br>　　对此，我的解决方案是：<br>　　１.　使用两个指针，一个用来指代当前节点(cur)，初始化为表头，另一个为前驱节点(pre)，可以在删除重复节点后，给下一个节点提供前驱信息，初始化为Null。<br>　　2.　从当前节点开始遍历链表，从简单的情况开始处理，即如果当前值不等于其后继值，那么非常lucky，这个节点不重复了，将前驱节点更新为当前节点，将当前节点更新为其后继节点，然后跳出本次循环，move on；<br>　　3.　如果相等呢？那我们就得顺着往下捋,即更新后继节点_next，直到不相等了，这时_next指向的是第一个不与前面节点重复的节点，而cur指向的是这批重复节点的第一个节点。那么这时要删除的话就有两种情况了:第一，如果重复段在表头，说明head要更新，更新为_next节点了，这时pre依旧指向Null，然后将cur更新为_next；第二，如果这批重复的是中间的批次，说明head不用更新了，但因为中间这批重复的全删了，所以pre的后继得更新为_next，和第一种情况一样，cur也要后移，即更新为_next。<br>　　代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">deleteDuplicates</span><span class=\"params\">(head)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type head: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> head:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 两个指针：pre和cur</span></span><br><span class=\"line\">        pre = <span class=\"keyword\">None</span></span><br><span class=\"line\">        cur = head</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 遍历所有节点</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> cur:</span><br><span class=\"line\">            <span class=\"comment\"># 一个临时指针指向cur的后继</span></span><br><span class=\"line\">            _next = cur.next</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> _next:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> head</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 如果两个值不相等，则将pre和cur都往后移</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> cur.val != _next.val:</span><br><span class=\"line\">                pre = cur</span><br><span class=\"line\">                cur = _next</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 如果相等，则将_next一直捋到不重复为止</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">while</span> _next <span class=\"keyword\">and</span> _next.val == cur.val:</span><br><span class=\"line\">                    _next = _next.next</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\"># 如果重复段在表头，则需要更新表头信息</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> cur == head:</span><br><span class=\"line\">                    head = _next</span><br><span class=\"line\">                <span class=\"comment\"># 如果重复段在中间，则需要将pre的后继更新为_next</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    pre.next = _next</span><br><span class=\"line\">                <span class=\"comment\"># 继续遍历</span></span><br><span class=\"line\">                cur = _next</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head</span><br></pre></td></tr></table></figure>\n<h2 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h2><p>　　测试：均已通过</p>\n<h2 id=\"思考：\"><a href=\"#思考：\" class=\"headerlink\" title=\"思考：\"></a>思考：</h2><p>　　１.　基础版是用迭代法，“凡是迭代即可递归”，试试递归如何实现？<br>　　2.　进阶版是最优化的吗？可以逛逛discuss看是否还可进一步优化？</p>\n","site":{"data":{}},"excerpt":"<p>　　自从前两天刷了那道链表的题之后觉得很有意思，奇妙的数据结构哇咔咔 ~ ~ ~ 但毕竟不是科班出身，对它的一些操作非常不熟悉，每次被各种head,tail,pre,next指来指去的东西绕得晕头转向。嗯，熟能生巧，所以我最近专注于刷链表相关的题目啊哈哈 ~ ~ ~</p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>　　这篇博客回顾的题目是删除链表中重复元素的问题（链表均已排好序）：</p>\n<p>　　基础版：只删除重复了的元素，即保证唯一性 （<a href=\"https://leetcode.com/problems/remove-duplicates-from-sorted-list/\" target=\"_blank\" rel=\"noopener\">Leetcode Problem 83</a> ）。</p>\n<p>　　进阶版：删除有重复出现过的元素，即如果元素重复了，就将其从链表中剔除 （<a href=\"https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii\" target=\"_blank\" rel=\"noopener\">Leetcode Problem 82</a> ）。</p>\n<p>　　发现我的语言很苍白，还是看实例吧：</p>\n<p>　　基础包：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.</span><br><span class=\"line\">Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3.</span><br></pre></td></tr></table></figure>\n<p>　　升级包：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.</span><br><span class=\"line\">Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3.</span><br></pre></td></tr></table></figure>\n<h2 id=\"解题思路及相关代码\"><a href=\"#解题思路及相关代码\" class=\"headerlink\" title=\"解题思路及相关代码\"></a>解题思路及相关代码</h2><h3 id=\"基础版\"><a href=\"#基础版\" class=\"headerlink\" title=\"基础版\"></a>基础版</h3><p>　　对于基础包而言，我们只需要一个指针，即下面代码中的cur，从head开始挨个遍历链表节点（所以链表已经排序好这个前提很重要），对于每个cur，将其与其后继的节点值比较，如果相同，说明这个后继需要删除，对链表而言，操作则相当简单，直接将cur的后继改为当前后继的后继即可。如果不同，说明没有与当前节点值重复的了，直接将当前节点后移即可，即将cur更新为当前节点的后继。<br>　　代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">deleteDuplicates</span><span class=\"params\">(head)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type head: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"comment\"># 链表为空的特殊情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> head:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head</span><br><span class=\"line\">        <span class=\"comment\"># 当前节点初始化为表头</span></span><br><span class=\"line\">        cur = head</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 遍历，循环条件为当前节点和当前节点的后继不为空</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> cur <span class=\"keyword\">and</span> cur.next:</span><br><span class=\"line\">            <span class=\"comment\"># 如果当前节点值和其后继值相等，则将其后继改为后继的后继</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> cur.val == cur.next.val:</span><br><span class=\"line\">                cur.next = cur.next.next</span><br><span class=\"line\">            <span class=\"comment\"># 如果不相等，则将当前节点更新</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                cur = cur.next</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head</span><br></pre></td></tr></table></figure>","more":"<h3 id=\"进阶版\"><a href=\"#进阶版\" class=\"headerlink\" title=\"进阶版\"></a>进阶版</h3><p>　　和基础版相比，进阶版的难度体现在两个方面：第一，因为重复出现过的元素需要删除，所以表头可能会被修改（如第一次出现的元素就重复的情况）；第二，因为重复出现过的元素很随机，所以一个指针不够提供足够的信息，比如上述例子中的第一个，在将3和4删除后，得知道5的前驱是2。<br>　　对此，我的解决方案是：<br>　　１.　使用两个指针，一个用来指代当前节点(cur)，初始化为表头，另一个为前驱节点(pre)，可以在删除重复节点后，给下一个节点提供前驱信息，初始化为Null。<br>　　2.　从当前节点开始遍历链表，从简单的情况开始处理，即如果当前值不等于其后继值，那么非常lucky，这个节点不重复了，将前驱节点更新为当前节点，将当前节点更新为其后继节点，然后跳出本次循环，move on；<br>　　3.　如果相等呢？那我们就得顺着往下捋,即更新后继节点_next，直到不相等了，这时_next指向的是第一个不与前面节点重复的节点，而cur指向的是这批重复节点的第一个节点。那么这时要删除的话就有两种情况了:第一，如果重复段在表头，说明head要更新，更新为_next节点了，这时pre依旧指向Null，然后将cur更新为_next；第二，如果这批重复的是中间的批次，说明head不用更新了，但因为中间这批重复的全删了，所以pre的后继得更新为_next，和第一种情况一样，cur也要后移，即更新为_next。<br>　　代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">deleteDuplicates</span><span class=\"params\">(head)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type head: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> head:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 两个指针：pre和cur</span></span><br><span class=\"line\">        pre = <span class=\"keyword\">None</span></span><br><span class=\"line\">        cur = head</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 遍历所有节点</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> cur:</span><br><span class=\"line\">            <span class=\"comment\"># 一个临时指针指向cur的后继</span></span><br><span class=\"line\">            _next = cur.next</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> _next:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> head</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 如果两个值不相等，则将pre和cur都往后移</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> cur.val != _next.val:</span><br><span class=\"line\">                pre = cur</span><br><span class=\"line\">                cur = _next</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 如果相等，则将_next一直捋到不重复为止</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">while</span> _next <span class=\"keyword\">and</span> _next.val == cur.val:</span><br><span class=\"line\">                    _next = _next.next</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\"># 如果重复段在表头，则需要更新表头信息</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> cur == head:</span><br><span class=\"line\">                    head = _next</span><br><span class=\"line\">                <span class=\"comment\"># 如果重复段在中间，则需要将pre的后继更新为_next</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    pre.next = _next</span><br><span class=\"line\">                <span class=\"comment\"># 继续遍历</span></span><br><span class=\"line\">                cur = _next</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head</span><br></pre></td></tr></table></figure>\n<h2 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h2><p>　　测试：均已通过</p>\n<h2 id=\"思考：\"><a href=\"#思考：\" class=\"headerlink\" title=\"思考：\"></a>思考：</h2><p>　　１.　基础版是用迭代法，“凡是迭代即可递归”，试试递归如何实现？<br>　　2.　进阶版是最优化的吗？可以逛逛discuss看是否还可进一步优化？</p>"},{"title":"PRML 之无处不在的高斯分布","date":"2017-10-21T15:50:57.000Z","mathjax":true,"_content":"\n　　之前零零散散看了一些统计学习相关的书和paper时就发现高斯老爷子的分布真是无处不在，可惜每次看别人运用高斯分布的时候，由于对高斯分布理解不深，所以他们的推导过程看着也是一知半解。最近看PRML这本书的时候，发现其中对高斯分布，主要是多元高斯分布，做了很详细地阐述，为了加深自己的理解和记忆，觉得有必要写篇笔记记录一下。\n\n导读：\n \n\n\n\n* [1. 多元高斯分布](#1)\n\n    * [1.1 期望和方差](#1.1)\n\n    * [1.2 条件高斯分布](#1.2)\n\n    * [1.3 边缘高斯分布](#1.3)\n\n    * [1.4 贝叶斯定理](#1.4)\n\n* [2. 参数估计]\n\n    * [2.1 极大似然估计](#2.1)\n    \n    * [2.2 贝叶斯推断](#2.2)\n\n    \n    \n\n<h2 id=\"1\">1. 多元高斯分布</h2>\n\n    \n我们假设一个$D$维向量$x = (x_1,x_2,...,x_D)^T$,意味着有$D$个变量，它们整体服从多元高斯分布：\n$$N(x|\\mu,\\Sigma) = (2\\pi)^{-D/2}|\\Sigma|^{-1/2}exp(-\\frac{1}{2}(x-\\mu)^T\\Sigma^{-1}(x-\\mu))$$ \n其中：\n\n$\\mu$：$D$维均值向量(mean vector)，即$\\mu = (\\mu_1, \\mu_2,...,\\mu_D)^T$\n\n$\\Sigma$：$D\\times D$的协方差矩阵(covariance matrix)，$\\Sigma_{ij}=(x_i-\\mu_i)(x_j-\\mu_j)$。\n\n\n我们可以从$N(x|\\mu, \\Sigma)$中的指数项出发，理解多元高斯分布的几何意义。\n\n首先，我们来看一下这个指数项  $\\Delta^2 = (x-\\mu)^T\\Sigma^{-1}(x-\\mu)$，发现其中主要包含两部分：一个是协方差矩阵$\\Sigma$，一个是平移后的$x$。\n\n若$\\Sigma$有D个特征值$\\lambda_1,\\lambda_2,...,\\lambda_D$，其对应的特征向量为$u_1, u_2, ..., u_D$，则$$\\Sigma = \\sum_{i=1}^{D}\\lambda_iu_iu_i^T$$\n其中，若所有$\\lambda_i$都大于0，则说$\\Sigma$是正定的(positive definite);若存在$\\lambda_i = 0$,则说该分布是奇异的，说明其可以在低维子空间表达；若所有$\\lambda$非负，则说明$\\Sigma$是半正定的(positive semidefinite)。\n\n$u_i$满足正交归一条件，即:\n\n$$u_i^Tu_j=I_{ij}=\n\\begin{cases}\n1& {i=j}\\\\\n0& {i\\neq j}\n\\end{cases}$$\n\n\n\n\n令$U=(u_1,u_2,...,u_D)$，则$UU^T = I$。因此：\n\\begin{equation}\n\\Delta^2 = \\sum_{i=1}^{D}(x-\\mu)^T\\lambda_i^{-1}u_iu_i^T(x-\\mu)\n\\end{equation}\n令$y_i = u_i^T(x-\\mu)$,可以看出这是一个数，那么$y_i^T = (x-\\mu)^Tu_i$也是个数。因此，\n\n\\begin{equation}\n\\Delta^2 = \\sum_{i=1}^{D}\\lambda_i^{-1}y_i^Ty_i=\\sum_{i=1}^{D}\\lambda_i^{-1}y_i^2\n\\end{equation}\n\n可见指数项由向量计算变成了普通的数值计算。可以看出，$y_i$就是$u_i$与$x-\\mu$的向量内积，也可以看作向量$x$先进行平移将重心移到原点变成$(x-\\mu)$，而后在基矢$u_i$上的投影值。因此，$y = (y_1,y_2,...,y_D)^T$ 可看作$x-\\mu$在基矢$U$张成的线性空间的新坐标值。所以从$x$到$y$是做了个线性变换，$y = U^T(x-\\mu), x= Uy+\\mu$。\n\n从$x$到$y$的坐标系统，其Jacobi矩阵为$J_{ij} = \\frac{\\partial x_i}{\\partial y_j}=U_{ij}$,$|J|^2 = |U|^2 = 1$, $|J| =1$。\n\n在$y$的坐标系统中，其分布为:\n\\begin{equation}\np(y) = p(x)|J| = \\prod_{i=1}^{D}(2\\pi\\lambda_i)^{-1/2}exp(-\\frac{y_1^2}{2\\lambda_i})\n\\end{equation}\n\n可见其中没有了矩阵的操作，而是简化成了$D$个普通的单变量高斯分布的相乘，且这个单变量高斯分布中：$\\mu = 0, \\sigma^2 = \\lambda$。\n <!-- more -->\n\n<h3 id=\"1.1\">1.1 期望和方差</h3>\n\n由上节可知，多元高斯分布可以表示为：\n$$\n\\begin{equation}\np(x)=(2\\pi)^{-D/2}\\Sigma^{-1/2}\\int exp(-\\frac{1}{2}\\Delta^2))\n\\end{equation}\n$$\n$$\\Delta^2 = (x-\\mu)^T\\Sigma^{-1}(x-\\mu)$$\n\n因此，计算其期望(expectation)可先作变换$z=x-\\mu$,则\n$$\n\\begin{equation}\nE[x] = (2\\pi)^{-D/2}\\Sigma^{-1/2}\\int exp(-\\frac{1}{2}z^T\\Sigma^{-1}z)(z+\\mu)dz\n\\end{equation}\n$$\n\n可见指数项是关于$z$的偶函数，而积分区间是$(-\\infty,\\infty)$,由对称性可知,与$z$的相乘项为0，积分简化为\n$$\n\\begin{equation}\n E[x]=\\mu \\cdot (2\\pi)^{-D/2}\\Sigma^{-1/2}\\int exp(-\\frac{1}{2}z^T\\Sigma^{-1}z)dz\n\\end{equation}\n$$\n\n$\\mu$后面的部分由归一化条件可知为1，所以，$E[x]=\\mu$。\n\n对多元高斯分布，我们对其方差，或者说协方差的求法和单变量高斯分布的类似，对单变量高斯分布，其一阶矩$E[x]=\\mu$，二阶矩$E[x^2]=\\mu^2+\\sigma^2$,即方差$\\sigma^2 = E[x^2]-E[x]^2$。因此，对多元高斯分布，我们首先求其二阶矩$E[x_ix_j]$,即$E[xx^T]$。\n\n$$\n\\begin{equation}  \nE[xx^T] = (2\\pi)^{-D/2}\\Sigma^{-1/2}\\int exp(-\\frac{1}{2}z^T\\Sigma^{-1}z)(z+\\mu)(z+\\mu)^Tdz\n\\end{equation}\n$$\n\n由对称性可知，所有的$\\mu z^T,z\\mu^T$项都为0，而$\\mu\\mu^T$为常数项，事实上，由上一步求期望可知，该项值其实就为$\\mu\\mu^T$。所以，在这里，我们需要考虑的只有 $zz^T$ 项。\n\n由上一部分的内容可知，我们可以通过将$z$投影到新的$y$坐标系,即$z=\\sum_{j=1}^{D}y_ju_j$，使计算大大简化。依此，$zz^T$项可表示为：\n\n$$\n\\begin{eqnarray}\nE[zz^T]&=&(2\\pi)^{-D/2}\\Sigma^{-1/2}\\int exp(-\\frac{1}{2}z^T\\Sigma^{-1}z)zz^Tdz\\\\\n& = &(2\\pi)^{-D/2}\\Sigma^{-1/2}\\sum_{i=1,j=1}^{D}u_iu_j^T\\int exp(-\\frac{1}{2}\\sum_{k=1}^D \\frac{y_k^2}{\\lambda_k})y_iy_jdy\n\\end{eqnarray}\n$$\n由对称性可知，只有$i=j=k$的项保留，且由于此处可运用单变量高斯分布中的结论$E[x^2]=\\mu^2+\\lambda^2$,而此积分项中，对应的$\\mu=0,\\sigma^2=\\lambda_k$，因此\n$$\n\\begin{equation}\n   E[zz^T]=\\sum_{i=1}^D u_iu_i^T\\lambda_i = \\Sigma \n\\end{equation}\n$$\n即$E[xx^T]=\\Sigma+\\mu\\mu^T$\n因此\n$$\n\\begin{equation}\ncov[x] = E[xx^T]-E[x]E[x]^T= \\Sigma\n\\end{equation}\n$$\n可见，上一节中多变量高斯分布表达式$N(x|\\mu,\\Sigma)$中的两个参数$\\mu$和$\\Sigma$即为该分布的期望和协方差。\n\n先写到这，剩下的慢慢更~~~\n\n\n<h3 id=\"1.2\">1.2 条件高斯分布</h3>\n\n假设 $x$ 是服从高斯分布 $N(x|\\mu,\\Sigma)$ 的 D 维向量，把 $x$ 划分为两个不相交的子集 $x_a,x_b$。不失一般性的，令 $x_a$ 为 $x$ 的前 M个分量，令 $x_b$ 为剩余的 D-M 个分量，得到：\n\n$$\n        \\begin{pmatrix}\n        x_a \\\\\n        x_b\n        \\end{pmatrix}\n$$\n对应的均值向量$\\mu$的划分：\n$$\n        \\begin{pmatrix}\n        \\mu_a \\\\\n        \\mu_b\n        \\end{pmatrix}\n$$\n协方差矩阵为：\n$$\n        \\begin{pmatrix}\n        \\Sigma_{aa} & \\Sigma_{ab} \\\\\n        \\Sigma_{ba} & \\Sigma_{bb}\n        \\end{pmatrix}\n$$\n这里我们通过取协方差的倒数来定义精度矩阵：$\\Lambda=\\Sigma^{-1}$，\n$$\n\\begin{pmatrix}\n\\Lambda_{aa} & \\Lambda_{ab} \\\\\n\\Lambda_{ba} & \\Lambda_{bb}\n\\end{pmatrix}\n$$\n\n定义条件概率$p(x)=p(x_a,x_b)$，即在$x_b$固定的前提下求$x_a$的分布，可知其也是一个高斯分布，因此我们可通过分析其指数项的特征来获悉具体的参数表达。\n\n---分割线-------\n\n首先，我们来看下任意高斯分布的指数项：\n$$\n\\begin{equation}\n   -\\frac{1}{2}(x-\\mu)^T\\Sigma^{-1}(x-\\mu)=-\\frac{1}{2}x^T\\Sigma^{-1}x+x^T\\Sigma^{-1}\\mu+const(\\text{indenpendent on x}) \n\\end{equation}\n$$\n又由于\n$$\n\\begin{equation}\n    -\\frac{1}{2}(x-\\mu)^T\\Sigma^{-1}(x-\\mu)=\\\\\n    -\\frac{1}{2}(x_a-\\mu_a)^T\\Sigma^{-1}(x_a-\\mu_a)-\\frac{1}{2}(x_a-\\mu_a)^T\\Sigma^{-1}(x_b-\\mu_b)\\\\\n    -\\frac{1}{2}(x_b-\\mu_b)^T\\Sigma^{-1}(x_a-\\mu_a)-\\frac{1}{2}(x_b-\\mu_b)^T\\Sigma^{-1}(x_a-\\mu_a)\n\\end{equation}\n$$\n\n\n\n<h3 id=\"1.3\">1.3 边缘高斯分布</h3>\n\n<h3 id=\"1.4\">1.4 贝叶斯定理</h3>\n\n<h2 id=\"2\">2. 参数估计</h2>\n\n<h3 id=\"2.1\">2.1 极大似然估计</h3>\n\n<h3 id=\"2.2\">2.2 贝叶斯估计</h3>","source":"_posts/PRML-之无处不在的高斯分布.md","raw":"---\ntitle: PRML 之无处不在的高斯分布\ndate: 2017-10-21 23:50:57\ntags: \n    - 机器学习\n    - 读书笔记\nmathjax: true\n---\n\n　　之前零零散散看了一些统计学习相关的书和paper时就发现高斯老爷子的分布真是无处不在，可惜每次看别人运用高斯分布的时候，由于对高斯分布理解不深，所以他们的推导过程看着也是一知半解。最近看PRML这本书的时候，发现其中对高斯分布，主要是多元高斯分布，做了很详细地阐述，为了加深自己的理解和记忆，觉得有必要写篇笔记记录一下。\n\n导读：\n \n\n\n\n* [1. 多元高斯分布](#1)\n\n    * [1.1 期望和方差](#1.1)\n\n    * [1.2 条件高斯分布](#1.2)\n\n    * [1.3 边缘高斯分布](#1.3)\n\n    * [1.4 贝叶斯定理](#1.4)\n\n* [2. 参数估计]\n\n    * [2.1 极大似然估计](#2.1)\n    \n    * [2.2 贝叶斯推断](#2.2)\n\n    \n    \n\n<h2 id=\"1\">1. 多元高斯分布</h2>\n\n    \n我们假设一个$D$维向量$x = (x_1,x_2,...,x_D)^T$,意味着有$D$个变量，它们整体服从多元高斯分布：\n$$N(x|\\mu,\\Sigma) = (2\\pi)^{-D/2}|\\Sigma|^{-1/2}exp(-\\frac{1}{2}(x-\\mu)^T\\Sigma^{-1}(x-\\mu))$$ \n其中：\n\n$\\mu$：$D$维均值向量(mean vector)，即$\\mu = (\\mu_1, \\mu_2,...,\\mu_D)^T$\n\n$\\Sigma$：$D\\times D$的协方差矩阵(covariance matrix)，$\\Sigma_{ij}=(x_i-\\mu_i)(x_j-\\mu_j)$。\n\n\n我们可以从$N(x|\\mu, \\Sigma)$中的指数项出发，理解多元高斯分布的几何意义。\n\n首先，我们来看一下这个指数项  $\\Delta^2 = (x-\\mu)^T\\Sigma^{-1}(x-\\mu)$，发现其中主要包含两部分：一个是协方差矩阵$\\Sigma$，一个是平移后的$x$。\n\n若$\\Sigma$有D个特征值$\\lambda_1,\\lambda_2,...,\\lambda_D$，其对应的特征向量为$u_1, u_2, ..., u_D$，则$$\\Sigma = \\sum_{i=1}^{D}\\lambda_iu_iu_i^T$$\n其中，若所有$\\lambda_i$都大于0，则说$\\Sigma$是正定的(positive definite);若存在$\\lambda_i = 0$,则说该分布是奇异的，说明其可以在低维子空间表达；若所有$\\lambda$非负，则说明$\\Sigma$是半正定的(positive semidefinite)。\n\n$u_i$满足正交归一条件，即:\n\n$$u_i^Tu_j=I_{ij}=\n\\begin{cases}\n1& {i=j}\\\\\n0& {i\\neq j}\n\\end{cases}$$\n\n\n\n\n令$U=(u_1,u_2,...,u_D)$，则$UU^T = I$。因此：\n\\begin{equation}\n\\Delta^2 = \\sum_{i=1}^{D}(x-\\mu)^T\\lambda_i^{-1}u_iu_i^T(x-\\mu)\n\\end{equation}\n令$y_i = u_i^T(x-\\mu)$,可以看出这是一个数，那么$y_i^T = (x-\\mu)^Tu_i$也是个数。因此，\n\n\\begin{equation}\n\\Delta^2 = \\sum_{i=1}^{D}\\lambda_i^{-1}y_i^Ty_i=\\sum_{i=1}^{D}\\lambda_i^{-1}y_i^2\n\\end{equation}\n\n可见指数项由向量计算变成了普通的数值计算。可以看出，$y_i$就是$u_i$与$x-\\mu$的向量内积，也可以看作向量$x$先进行平移将重心移到原点变成$(x-\\mu)$，而后在基矢$u_i$上的投影值。因此，$y = (y_1,y_2,...,y_D)^T$ 可看作$x-\\mu$在基矢$U$张成的线性空间的新坐标值。所以从$x$到$y$是做了个线性变换，$y = U^T(x-\\mu), x= Uy+\\mu$。\n\n从$x$到$y$的坐标系统，其Jacobi矩阵为$J_{ij} = \\frac{\\partial x_i}{\\partial y_j}=U_{ij}$,$|J|^2 = |U|^2 = 1$, $|J| =1$。\n\n在$y$的坐标系统中，其分布为:\n\\begin{equation}\np(y) = p(x)|J| = \\prod_{i=1}^{D}(2\\pi\\lambda_i)^{-1/2}exp(-\\frac{y_1^2}{2\\lambda_i})\n\\end{equation}\n\n可见其中没有了矩阵的操作，而是简化成了$D$个普通的单变量高斯分布的相乘，且这个单变量高斯分布中：$\\mu = 0, \\sigma^2 = \\lambda$。\n <!-- more -->\n\n<h3 id=\"1.1\">1.1 期望和方差</h3>\n\n由上节可知，多元高斯分布可以表示为：\n$$\n\\begin{equation}\np(x)=(2\\pi)^{-D/2}\\Sigma^{-1/2}\\int exp(-\\frac{1}{2}\\Delta^2))\n\\end{equation}\n$$\n$$\\Delta^2 = (x-\\mu)^T\\Sigma^{-1}(x-\\mu)$$\n\n因此，计算其期望(expectation)可先作变换$z=x-\\mu$,则\n$$\n\\begin{equation}\nE[x] = (2\\pi)^{-D/2}\\Sigma^{-1/2}\\int exp(-\\frac{1}{2}z^T\\Sigma^{-1}z)(z+\\mu)dz\n\\end{equation}\n$$\n\n可见指数项是关于$z$的偶函数，而积分区间是$(-\\infty,\\infty)$,由对称性可知,与$z$的相乘项为0，积分简化为\n$$\n\\begin{equation}\n E[x]=\\mu \\cdot (2\\pi)^{-D/2}\\Sigma^{-1/2}\\int exp(-\\frac{1}{2}z^T\\Sigma^{-1}z)dz\n\\end{equation}\n$$\n\n$\\mu$后面的部分由归一化条件可知为1，所以，$E[x]=\\mu$。\n\n对多元高斯分布，我们对其方差，或者说协方差的求法和单变量高斯分布的类似，对单变量高斯分布，其一阶矩$E[x]=\\mu$，二阶矩$E[x^2]=\\mu^2+\\sigma^2$,即方差$\\sigma^2 = E[x^2]-E[x]^2$。因此，对多元高斯分布，我们首先求其二阶矩$E[x_ix_j]$,即$E[xx^T]$。\n\n$$\n\\begin{equation}  \nE[xx^T] = (2\\pi)^{-D/2}\\Sigma^{-1/2}\\int exp(-\\frac{1}{2}z^T\\Sigma^{-1}z)(z+\\mu)(z+\\mu)^Tdz\n\\end{equation}\n$$\n\n由对称性可知，所有的$\\mu z^T,z\\mu^T$项都为0，而$\\mu\\mu^T$为常数项，事实上，由上一步求期望可知，该项值其实就为$\\mu\\mu^T$。所以，在这里，我们需要考虑的只有 $zz^T$ 项。\n\n由上一部分的内容可知，我们可以通过将$z$投影到新的$y$坐标系,即$z=\\sum_{j=1}^{D}y_ju_j$，使计算大大简化。依此，$zz^T$项可表示为：\n\n$$\n\\begin{eqnarray}\nE[zz^T]&=&(2\\pi)^{-D/2}\\Sigma^{-1/2}\\int exp(-\\frac{1}{2}z^T\\Sigma^{-1}z)zz^Tdz\\\\\n& = &(2\\pi)^{-D/2}\\Sigma^{-1/2}\\sum_{i=1,j=1}^{D}u_iu_j^T\\int exp(-\\frac{1}{2}\\sum_{k=1}^D \\frac{y_k^2}{\\lambda_k})y_iy_jdy\n\\end{eqnarray}\n$$\n由对称性可知，只有$i=j=k$的项保留，且由于此处可运用单变量高斯分布中的结论$E[x^2]=\\mu^2+\\lambda^2$,而此积分项中，对应的$\\mu=0,\\sigma^2=\\lambda_k$，因此\n$$\n\\begin{equation}\n   E[zz^T]=\\sum_{i=1}^D u_iu_i^T\\lambda_i = \\Sigma \n\\end{equation}\n$$\n即$E[xx^T]=\\Sigma+\\mu\\mu^T$\n因此\n$$\n\\begin{equation}\ncov[x] = E[xx^T]-E[x]E[x]^T= \\Sigma\n\\end{equation}\n$$\n可见，上一节中多变量高斯分布表达式$N(x|\\mu,\\Sigma)$中的两个参数$\\mu$和$\\Sigma$即为该分布的期望和协方差。\n\n先写到这，剩下的慢慢更~~~\n\n\n<h3 id=\"1.2\">1.2 条件高斯分布</h3>\n\n假设 $x$ 是服从高斯分布 $N(x|\\mu,\\Sigma)$ 的 D 维向量，把 $x$ 划分为两个不相交的子集 $x_a,x_b$。不失一般性的，令 $x_a$ 为 $x$ 的前 M个分量，令 $x_b$ 为剩余的 D-M 个分量，得到：\n\n$$\n        \\begin{pmatrix}\n        x_a \\\\\n        x_b\n        \\end{pmatrix}\n$$\n对应的均值向量$\\mu$的划分：\n$$\n        \\begin{pmatrix}\n        \\mu_a \\\\\n        \\mu_b\n        \\end{pmatrix}\n$$\n协方差矩阵为：\n$$\n        \\begin{pmatrix}\n        \\Sigma_{aa} & \\Sigma_{ab} \\\\\n        \\Sigma_{ba} & \\Sigma_{bb}\n        \\end{pmatrix}\n$$\n这里我们通过取协方差的倒数来定义精度矩阵：$\\Lambda=\\Sigma^{-1}$，\n$$\n\\begin{pmatrix}\n\\Lambda_{aa} & \\Lambda_{ab} \\\\\n\\Lambda_{ba} & \\Lambda_{bb}\n\\end{pmatrix}\n$$\n\n定义条件概率$p(x)=p(x_a,x_b)$，即在$x_b$固定的前提下求$x_a$的分布，可知其也是一个高斯分布，因此我们可通过分析其指数项的特征来获悉具体的参数表达。\n\n---分割线-------\n\n首先，我们来看下任意高斯分布的指数项：\n$$\n\\begin{equation}\n   -\\frac{1}{2}(x-\\mu)^T\\Sigma^{-1}(x-\\mu)=-\\frac{1}{2}x^T\\Sigma^{-1}x+x^T\\Sigma^{-1}\\mu+const(\\text{indenpendent on x}) \n\\end{equation}\n$$\n又由于\n$$\n\\begin{equation}\n    -\\frac{1}{2}(x-\\mu)^T\\Sigma^{-1}(x-\\mu)=\\\\\n    -\\frac{1}{2}(x_a-\\mu_a)^T\\Sigma^{-1}(x_a-\\mu_a)-\\frac{1}{2}(x_a-\\mu_a)^T\\Sigma^{-1}(x_b-\\mu_b)\\\\\n    -\\frac{1}{2}(x_b-\\mu_b)^T\\Sigma^{-1}(x_a-\\mu_a)-\\frac{1}{2}(x_b-\\mu_b)^T\\Sigma^{-1}(x_a-\\mu_a)\n\\end{equation}\n$$\n\n\n\n<h3 id=\"1.3\">1.3 边缘高斯分布</h3>\n\n<h3 id=\"1.4\">1.4 贝叶斯定理</h3>\n\n<h2 id=\"2\">2. 参数估计</h2>\n\n<h3 id=\"2.1\">2.1 极大似然估计</h3>\n\n<h3 id=\"2.2\">2.2 贝叶斯估计</h3>","slug":"PRML-之无处不在的高斯分布","published":1,"updated":"2018-01-16T03:43:02.892Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcknckyu0006souy4atz3t8w","content":"<p>　　之前零零散散看了一些统计学习相关的书和paper时就发现高斯老爷子的分布真是无处不在，可惜每次看别人运用高斯分布的时候，由于对高斯分布理解不深，所以他们的推导过程看着也是一知半解。最近看PRML这本书的时候，发现其中对高斯分布，主要是多元高斯分布，做了很详细地阐述，为了加深自己的理解和记忆，觉得有必要写篇笔记记录一下。</p>\n<p>导读：</p>\n<ul>\n<li><p><a href=\"#1\">1. 多元高斯分布</a></p>\n<ul>\n<li><p><a href=\"#1.1\">1.1 期望和方差</a></p>\n</li>\n<li><p><a href=\"#1.2\">1.2 条件高斯分布</a></p>\n</li>\n<li><p><a href=\"#1.3\">1.3 边缘高斯分布</a></p>\n</li>\n<li><p><a href=\"#1.4\">1.4 贝叶斯定理</a></p>\n</li>\n</ul>\n</li>\n<li><p>[2. 参数估计]</p>\n<ul>\n<li><p><a href=\"#2.1\">2.1 极大似然估计</a></p>\n</li>\n<li><p><a href=\"#2.2\">2.2 贝叶斯推断</a></p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"1\">1. 多元高斯分布</h2>\n\n\n<p>我们假设一个$D$维向量$x = (x_1,x_2,…,x_D)^T$,意味着有$D$个变量，它们整体服从多元高斯分布：</p>\n<script type=\"math/tex; mode=display\">N(x|\\mu,\\Sigma) = (2\\pi)^{-D/2}|\\Sigma|^{-1/2}exp(-\\frac{1}{2}(x-\\mu)^T\\Sigma^{-1}(x-\\mu))</script><p>其中：</p>\n<p>$\\mu$：$D$维均值向量(mean vector)，即$\\mu = (\\mu_1, \\mu_2,…,\\mu_D)^T$</p>\n<p>$\\Sigma$：$D\\times D$的协方差矩阵(covariance matrix)，$\\Sigma_{ij}=(x_i-\\mu_i)(x_j-\\mu_j)$。</p>\n<p>我们可以从$N(x|\\mu, \\Sigma)$中的指数项出发，理解多元高斯分布的几何意义。</p>\n<p>首先，我们来看一下这个指数项  $\\Delta^2 = (x-\\mu)^T\\Sigma^{-1}(x-\\mu)$，发现其中主要包含两部分：一个是协方差矩阵$\\Sigma$，一个是平移后的$x$。</p>\n<p>若$\\Sigma$有D个特征值$\\lambda_1,\\lambda_2,…,\\lambda_D$，其对应的特征向量为$u_1, u_2, …, u_D$，则<script type=\"math/tex\">\\Sigma = \\sum_{i=1}^{D}\\lambda_iu_iu_i^T</script><br>其中，若所有$\\lambda_i$都大于0，则说$\\Sigma$是正定的(positive definite);若存在$\\lambda_i = 0$,则说该分布是奇异的，说明其可以在低维子空间表达；若所有$\\lambda$非负，则说明$\\Sigma$是半正定的(positive semidefinite)。</p>\n<p>$u_i$满足正交归一条件，即:</p>\n<script type=\"math/tex; mode=display\">u_i^Tu_j=I_{ij}=\n\\begin{cases}\n1& {i=j}\\\\\n0& {i\\neq j}\n\\end{cases}</script><p>令$U=(u_1,u_2,…,u_D)$，则$UU^T = I$。因此：<br>\\begin{equation}<br>\\Delta^2 = \\sum_{i=1}^{D}(x-\\mu)^T\\lambda_i^{-1}u_iu_i^T(x-\\mu)<br>\\end{equation}<br>令$y_i = u_i^T(x-\\mu)$,可以看出这是一个数，那么$y_i^T = (x-\\mu)^Tu_i$也是个数。因此，</p>\n<p>\\begin{equation}<br>\\Delta^2 = \\sum_{i=1}^{D}\\lambda_i^{-1}y_i^Ty_i=\\sum_{i=1}^{D}\\lambda_i^{-1}y_i^2<br>\\end{equation}</p>\n<p>可见指数项由向量计算变成了普通的数值计算。可以看出，$y_i$就是$u_i$与$x-\\mu$的向量内积，也可以看作向量$x$先进行平移将重心移到原点变成$(x-\\mu)$，而后在基矢$u_i$上的投影值。因此，$y = (y_1,y_2,…,y_D)^T$ 可看作$x-\\mu$在基矢$U$张成的线性空间的新坐标值。所以从$x$到$y$是做了个线性变换，$y = U^T(x-\\mu), x= Uy+\\mu$。</p>\n<p>从$x$到$y$的坐标系统，其Jacobi矩阵为$J_{ij} = \\frac{\\partial x_i}{\\partial y_j}=U_{ij}$,$|J|^2 = |U|^2 = 1$, $|J| =1$。</p>\n<p>在$y$的坐标系统中，其分布为:<br>\\begin{equation}<br>p(y) = p(x)|J| = \\prod_{i=1}^{D}(2\\pi\\lambda_i)^{-1/2}exp(-\\frac{y_1^2}{2\\lambda_i})<br>\\end{equation}</p>\n<p>可见其中没有了矩阵的操作，而是简化成了$D$个普通的单变量高斯分布的相乘，且这个单变量高斯分布中：$\\mu = 0, \\sigma^2 = \\lambda$。<br> <a id=\"more\"></a></p>\n<h3 id=\"1.1\">1.1 期望和方差</h3>\n\n<p>由上节可知，多元高斯分布可以表示为：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\np(x)=(2\\pi)^{-D/2}\\Sigma^{-1/2}\\int exp(-\\frac{1}{2}\\Delta^2))\n\\end{equation}</script><script type=\"math/tex; mode=display\">\\Delta^2 = (x-\\mu)^T\\Sigma^{-1}(x-\\mu)</script><p>因此，计算其期望(expectation)可先作变换$z=x-\\mu$,则</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\nE[x] = (2\\pi)^{-D/2}\\Sigma^{-1/2}\\int exp(-\\frac{1}{2}z^T\\Sigma^{-1}z)(z+\\mu)dz\n\\end{equation}</script><p>可见指数项是关于$z$的偶函数，而积分区间是$(-\\infty,\\infty)$,由对称性可知,与$z$的相乘项为0，积分简化为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n E[x]=\\mu \\cdot (2\\pi)^{-D/2}\\Sigma^{-1/2}\\int exp(-\\frac{1}{2}z^T\\Sigma^{-1}z)dz\n\\end{equation}</script><p>$\\mu$后面的部分由归一化条件可知为1，所以，$E[x]=\\mu$。</p>\n<p>对多元高斯分布，我们对其方差，或者说协方差的求法和单变量高斯分布的类似，对单变量高斯分布，其一阶矩$E[x]=\\mu$，二阶矩$E[x^2]=\\mu^2+\\sigma^2$,即方差$\\sigma^2 = E[x^2]-E[x]^2$。因此，对多元高斯分布，我们首先求其二阶矩$E[x_ix_j]$,即$E[xx^T]$。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}  \nE[xx^T] = (2\\pi)^{-D/2}\\Sigma^{-1/2}\\int exp(-\\frac{1}{2}z^T\\Sigma^{-1}z)(z+\\mu)(z+\\mu)^Tdz\n\\end{equation}</script><p>由对称性可知，所有的$\\mu z^T,z\\mu^T$项都为0，而$\\mu\\mu^T$为常数项，事实上，由上一步求期望可知，该项值其实就为$\\mu\\mu^T$。所以，在这里，我们需要考虑的只有 $zz^T$ 项。</p>\n<p>由上一部分的内容可知，我们可以通过将$z$投影到新的$y$坐标系,即$z=\\sum_{j=1}^{D}y_ju_j$，使计算大大简化。依此，$zz^T$项可表示为：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{eqnarray}\nE[zz^T]&=&(2\\pi)^{-D/2}\\Sigma^{-1/2}\\int exp(-\\frac{1}{2}z^T\\Sigma^{-1}z)zz^Tdz\\\\\n& = &(2\\pi)^{-D/2}\\Sigma^{-1/2}\\sum_{i=1,j=1}^{D}u_iu_j^T\\int exp(-\\frac{1}{2}\\sum_{k=1}^D \\frac{y_k^2}{\\lambda_k})y_iy_jdy\n\\end{eqnarray}</script><p>由对称性可知，只有$i=j=k$的项保留，且由于此处可运用单变量高斯分布中的结论$E[x^2]=\\mu^2+\\lambda^2$,而此积分项中，对应的$\\mu=0,\\sigma^2=\\lambda_k$，因此</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n   E[zz^T]=\\sum_{i=1}^D u_iu_i^T\\lambda_i = \\Sigma \n\\end{equation}</script><p>即$E[xx^T]=\\Sigma+\\mu\\mu^T$<br>因此</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\ncov[x] = E[xx^T]-E[x]E[x]^T= \\Sigma\n\\end{equation}</script><p>可见，上一节中多变量高斯分布表达式$N(x|\\mu,\\Sigma)$中的两个参数$\\mu$和$\\Sigma$即为该分布的期望和协方差。</p>\n<p>先写到这，剩下的慢慢更~~~</p>\n<h3 id=\"1.2\">1.2 条件高斯分布</h3>\n\n<p>假设 $x$ 是服从高斯分布 $N(x|\\mu,\\Sigma)$ 的 D 维向量，把 $x$ 划分为两个不相交的子集 $x_a,x_b$。不失一般性的，令 $x_a$ 为 $x$ 的前 M个分量，令 $x_b$ 为剩余的 D-M 个分量，得到：</p>\n<script type=\"math/tex; mode=display\">\n        \\begin{pmatrix}\n        x_a \\\\\n        x_b\n        \\end{pmatrix}</script><p>对应的均值向量$\\mu$的划分：</p>\n<script type=\"math/tex; mode=display\">\n        \\begin{pmatrix}\n        \\mu_a \\\\\n        \\mu_b\n        \\end{pmatrix}</script><p>协方差矩阵为：</p>\n<script type=\"math/tex; mode=display\">\n        \\begin{pmatrix}\n        \\Sigma_{aa} & \\Sigma_{ab} \\\\\n        \\Sigma_{ba} & \\Sigma_{bb}\n        \\end{pmatrix}</script><p>这里我们通过取协方差的倒数来定义精度矩阵：$\\Lambda=\\Sigma^{-1}$，</p>\n<script type=\"math/tex; mode=display\">\n\\begin{pmatrix}\n\\Lambda_{aa} & \\Lambda_{ab} \\\\\n\\Lambda_{ba} & \\Lambda_{bb}\n\\end{pmatrix}</script><p>定义条件概率$p(x)=p(x_a,x_b)$，即在$x_b$固定的前提下求$x_a$的分布，可知其也是一个高斯分布，因此我们可通过分析其指数项的特征来获悉具体的参数表达。</p>\n<p>—-分割线———-</p>\n<p>首先，我们来看下任意高斯分布的指数项：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n   -\\frac{1}{2}(x-\\mu)^T\\Sigma^{-1}(x-\\mu)=-\\frac{1}{2}x^T\\Sigma^{-1}x+x^T\\Sigma^{-1}\\mu+const(\\text{indenpendent on x}) \n\\end{equation}</script><p>又由于</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n    -\\frac{1}{2}(x-\\mu)^T\\Sigma^{-1}(x-\\mu)=\\\\\n    -\\frac{1}{2}(x_a-\\mu_a)^T\\Sigma^{-1}(x_a-\\mu_a)-\\frac{1}{2}(x_a-\\mu_a)^T\\Sigma^{-1}(x_b-\\mu_b)\\\\\n    -\\frac{1}{2}(x_b-\\mu_b)^T\\Sigma^{-1}(x_a-\\mu_a)-\\frac{1}{2}(x_b-\\mu_b)^T\\Sigma^{-1}(x_a-\\mu_a)\n\\end{equation}</script><h3 id=\"1.3\">1.3 边缘高斯分布</h3>\n\n<h3 id=\"1.4\">1.4 贝叶斯定理</h3>\n\n<h2 id=\"2\">2. 参数估计</h2>\n\n<h3 id=\"2.1\">2.1 极大似然估计</h3>\n\n<h3 id=\"2.2\">2.2 贝叶斯估计</h3>","site":{"data":{}},"excerpt":"<p>　　之前零零散散看了一些统计学习相关的书和paper时就发现高斯老爷子的分布真是无处不在，可惜每次看别人运用高斯分布的时候，由于对高斯分布理解不深，所以他们的推导过程看着也是一知半解。最近看PRML这本书的时候，发现其中对高斯分布，主要是多元高斯分布，做了很详细地阐述，为了加深自己的理解和记忆，觉得有必要写篇笔记记录一下。</p>\n<p>导读：</p>\n<ul>\n<li><p><a href=\"#1\">1. 多元高斯分布</a></p>\n<ul>\n<li><p><a href=\"#1.1\">1.1 期望和方差</a></p>\n</li>\n<li><p><a href=\"#1.2\">1.2 条件高斯分布</a></p>\n</li>\n<li><p><a href=\"#1.3\">1.3 边缘高斯分布</a></p>\n</li>\n<li><p><a href=\"#1.4\">1.4 贝叶斯定理</a></p>\n</li>\n</ul>\n</li>\n<li><p>[2. 参数估计]</p>\n<ul>\n<li><p><a href=\"#2.1\">2.1 极大似然估计</a></p>\n</li>\n<li><p><a href=\"#2.2\">2.2 贝叶斯推断</a></p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"1\">1. 多元高斯分布</h2>\n\n\n<p>我们假设一个$D$维向量$x = (x_1,x_2,…,x_D)^T$,意味着有$D$个变量，它们整体服从多元高斯分布：</p>\n<script type=\"math/tex; mode=display\">N(x|\\mu,\\Sigma) = (2\\pi)^{-D/2}|\\Sigma|^{-1/2}exp(-\\frac{1}{2}(x-\\mu)^T\\Sigma^{-1}(x-\\mu))</script><p>其中：</p>\n<p>$\\mu$：$D$维均值向量(mean vector)，即$\\mu = (\\mu_1, \\mu_2,…,\\mu_D)^T$</p>\n<p>$\\Sigma$：$D\\times D$的协方差矩阵(covariance matrix)，$\\Sigma_{ij}=(x_i-\\mu_i)(x_j-\\mu_j)$。</p>\n<p>我们可以从$N(x|\\mu, \\Sigma)$中的指数项出发，理解多元高斯分布的几何意义。</p>\n<p>首先，我们来看一下这个指数项  $\\Delta^2 = (x-\\mu)^T\\Sigma^{-1}(x-\\mu)$，发现其中主要包含两部分：一个是协方差矩阵$\\Sigma$，一个是平移后的$x$。</p>\n<p>若$\\Sigma$有D个特征值$\\lambda_1,\\lambda_2,…,\\lambda_D$，其对应的特征向量为$u_1, u_2, …, u_D$，则<script type=\"math/tex\">\\Sigma = \\sum_{i=1}^{D}\\lambda_iu_iu_i^T</script><br>其中，若所有$\\lambda_i$都大于0，则说$\\Sigma$是正定的(positive definite);若存在$\\lambda_i = 0$,则说该分布是奇异的，说明其可以在低维子空间表达；若所有$\\lambda$非负，则说明$\\Sigma$是半正定的(positive semidefinite)。</p>\n<p>$u_i$满足正交归一条件，即:</p>\n<script type=\"math/tex; mode=display\">u_i^Tu_j=I_{ij}=\n\\begin{cases}\n1& {i=j}\\\\\n0& {i\\neq j}\n\\end{cases}</script><p>令$U=(u_1,u_2,…,u_D)$，则$UU^T = I$。因此：<br>\\begin{equation}<br>\\Delta^2 = \\sum_{i=1}^{D}(x-\\mu)^T\\lambda_i^{-1}u_iu_i^T(x-\\mu)<br>\\end{equation}<br>令$y_i = u_i^T(x-\\mu)$,可以看出这是一个数，那么$y_i^T = (x-\\mu)^Tu_i$也是个数。因此，</p>\n<p>\\begin{equation}<br>\\Delta^2 = \\sum_{i=1}^{D}\\lambda_i^{-1}y_i^Ty_i=\\sum_{i=1}^{D}\\lambda_i^{-1}y_i^2<br>\\end{equation}</p>\n<p>可见指数项由向量计算变成了普通的数值计算。可以看出，$y_i$就是$u_i$与$x-\\mu$的向量内积，也可以看作向量$x$先进行平移将重心移到原点变成$(x-\\mu)$，而后在基矢$u_i$上的投影值。因此，$y = (y_1,y_2,…,y_D)^T$ 可看作$x-\\mu$在基矢$U$张成的线性空间的新坐标值。所以从$x$到$y$是做了个线性变换，$y = U^T(x-\\mu), x= Uy+\\mu$。</p>\n<p>从$x$到$y$的坐标系统，其Jacobi矩阵为$J_{ij} = \\frac{\\partial x_i}{\\partial y_j}=U_{ij}$,$|J|^2 = |U|^2 = 1$, $|J| =1$。</p>\n<p>在$y$的坐标系统中，其分布为:<br>\\begin{equation}<br>p(y) = p(x)|J| = \\prod_{i=1}^{D}(2\\pi\\lambda_i)^{-1/2}exp(-\\frac{y_1^2}{2\\lambda_i})<br>\\end{equation}</p>\n<p>可见其中没有了矩阵的操作，而是简化成了$D$个普通的单变量高斯分布的相乘，且这个单变量高斯分布中：$\\mu = 0, \\sigma^2 = \\lambda$。<br>","more":"</p>\n<h3 id=\"1.1\">1.1 期望和方差</h3>\n\n<p>由上节可知，多元高斯分布可以表示为：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\np(x)=(2\\pi)^{-D/2}\\Sigma^{-1/2}\\int exp(-\\frac{1}{2}\\Delta^2))\n\\end{equation}</script><script type=\"math/tex; mode=display\">\\Delta^2 = (x-\\mu)^T\\Sigma^{-1}(x-\\mu)</script><p>因此，计算其期望(expectation)可先作变换$z=x-\\mu$,则</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\nE[x] = (2\\pi)^{-D/2}\\Sigma^{-1/2}\\int exp(-\\frac{1}{2}z^T\\Sigma^{-1}z)(z+\\mu)dz\n\\end{equation}</script><p>可见指数项是关于$z$的偶函数，而积分区间是$(-\\infty,\\infty)$,由对称性可知,与$z$的相乘项为0，积分简化为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n E[x]=\\mu \\cdot (2\\pi)^{-D/2}\\Sigma^{-1/2}\\int exp(-\\frac{1}{2}z^T\\Sigma^{-1}z)dz\n\\end{equation}</script><p>$\\mu$后面的部分由归一化条件可知为1，所以，$E[x]=\\mu$。</p>\n<p>对多元高斯分布，我们对其方差，或者说协方差的求法和单变量高斯分布的类似，对单变量高斯分布，其一阶矩$E[x]=\\mu$，二阶矩$E[x^2]=\\mu^2+\\sigma^2$,即方差$\\sigma^2 = E[x^2]-E[x]^2$。因此，对多元高斯分布，我们首先求其二阶矩$E[x_ix_j]$,即$E[xx^T]$。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}  \nE[xx^T] = (2\\pi)^{-D/2}\\Sigma^{-1/2}\\int exp(-\\frac{1}{2}z^T\\Sigma^{-1}z)(z+\\mu)(z+\\mu)^Tdz\n\\end{equation}</script><p>由对称性可知，所有的$\\mu z^T,z\\mu^T$项都为0，而$\\mu\\mu^T$为常数项，事实上，由上一步求期望可知，该项值其实就为$\\mu\\mu^T$。所以，在这里，我们需要考虑的只有 $zz^T$ 项。</p>\n<p>由上一部分的内容可知，我们可以通过将$z$投影到新的$y$坐标系,即$z=\\sum_{j=1}^{D}y_ju_j$，使计算大大简化。依此，$zz^T$项可表示为：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{eqnarray}\nE[zz^T]&=&(2\\pi)^{-D/2}\\Sigma^{-1/2}\\int exp(-\\frac{1}{2}z^T\\Sigma^{-1}z)zz^Tdz\\\\\n& = &(2\\pi)^{-D/2}\\Sigma^{-1/2}\\sum_{i=1,j=1}^{D}u_iu_j^T\\int exp(-\\frac{1}{2}\\sum_{k=1}^D \\frac{y_k^2}{\\lambda_k})y_iy_jdy\n\\end{eqnarray}</script><p>由对称性可知，只有$i=j=k$的项保留，且由于此处可运用单变量高斯分布中的结论$E[x^2]=\\mu^2+\\lambda^2$,而此积分项中，对应的$\\mu=0,\\sigma^2=\\lambda_k$，因此</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n   E[zz^T]=\\sum_{i=1}^D u_iu_i^T\\lambda_i = \\Sigma \n\\end{equation}</script><p>即$E[xx^T]=\\Sigma+\\mu\\mu^T$<br>因此</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\ncov[x] = E[xx^T]-E[x]E[x]^T= \\Sigma\n\\end{equation}</script><p>可见，上一节中多变量高斯分布表达式$N(x|\\mu,\\Sigma)$中的两个参数$\\mu$和$\\Sigma$即为该分布的期望和协方差。</p>\n<p>先写到这，剩下的慢慢更~~~</p>\n<h3 id=\"1.2\">1.2 条件高斯分布</h3>\n\n<p>假设 $x$ 是服从高斯分布 $N(x|\\mu,\\Sigma)$ 的 D 维向量，把 $x$ 划分为两个不相交的子集 $x_a,x_b$。不失一般性的，令 $x_a$ 为 $x$ 的前 M个分量，令 $x_b$ 为剩余的 D-M 个分量，得到：</p>\n<script type=\"math/tex; mode=display\">\n        \\begin{pmatrix}\n        x_a \\\\\n        x_b\n        \\end{pmatrix}</script><p>对应的均值向量$\\mu$的划分：</p>\n<script type=\"math/tex; mode=display\">\n        \\begin{pmatrix}\n        \\mu_a \\\\\n        \\mu_b\n        \\end{pmatrix}</script><p>协方差矩阵为：</p>\n<script type=\"math/tex; mode=display\">\n        \\begin{pmatrix}\n        \\Sigma_{aa} & \\Sigma_{ab} \\\\\n        \\Sigma_{ba} & \\Sigma_{bb}\n        \\end{pmatrix}</script><p>这里我们通过取协方差的倒数来定义精度矩阵：$\\Lambda=\\Sigma^{-1}$，</p>\n<script type=\"math/tex; mode=display\">\n\\begin{pmatrix}\n\\Lambda_{aa} & \\Lambda_{ab} \\\\\n\\Lambda_{ba} & \\Lambda_{bb}\n\\end{pmatrix}</script><p>定义条件概率$p(x)=p(x_a,x_b)$，即在$x_b$固定的前提下求$x_a$的分布，可知其也是一个高斯分布，因此我们可通过分析其指数项的特征来获悉具体的参数表达。</p>\n<p>—-分割线———-</p>\n<p>首先，我们来看下任意高斯分布的指数项：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n   -\\frac{1}{2}(x-\\mu)^T\\Sigma^{-1}(x-\\mu)=-\\frac{1}{2}x^T\\Sigma^{-1}x+x^T\\Sigma^{-1}\\mu+const(\\text{indenpendent on x}) \n\\end{equation}</script><p>又由于</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n    -\\frac{1}{2}(x-\\mu)^T\\Sigma^{-1}(x-\\mu)=\\\\\n    -\\frac{1}{2}(x_a-\\mu_a)^T\\Sigma^{-1}(x_a-\\mu_a)-\\frac{1}{2}(x_a-\\mu_a)^T\\Sigma^{-1}(x_b-\\mu_b)\\\\\n    -\\frac{1}{2}(x_b-\\mu_b)^T\\Sigma^{-1}(x_a-\\mu_a)-\\frac{1}{2}(x_b-\\mu_b)^T\\Sigma^{-1}(x_a-\\mu_a)\n\\end{equation}</script><h3 id=\"1.3\">1.3 边缘高斯分布</h3>\n\n<h3 id=\"1.4\">1.4 贝叶斯定理</h3>\n\n<h2 id=\"2\">2. 参数估计</h2>\n\n<h3 id=\"2.1\">2.1 极大似然估计</h3>\n\n<h3 id=\"2.2\">2.2 贝叶斯估计</h3>"},{"title":"Leetcode之旅|链表啊，链表 (0)","date":"2018-01-15T13:06:37.000Z","catogories":["Leetcode"],"mathjax":true,"_content":"\n　　由于近期状态不太好，很久没更新博客了，惭愧三秒钟。\n\n　　今天放纵自我刷题刷了半天，本来怂怂的我只敢挑战“easy”的题，后来刷了几道linked list的题后，胆儿肥了，刷了道hard模式的题，折腾了将近两个小时，才Pass，现在一把辛酸泪地把思路给记录下来，免得忘记。\n\n  Problem 25: Reverse Nodes in k-Group\n\n  Description:\n\n  ---\n\nGiven a linked list, reverse the nodes of a linked list k at a time and return its modified list.\n\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\n\nYou may not alter the values in the nodes, only nodes itself may be changed.\n\nOnly constant memory is allowed.\n\nFor example,\n```python\nGiven this linked list: 1->2->3->4->5\n\nFor k = 2, you should return: 2->1->4->3->5\n\nFor k = 3, you should return: 3->2->1->4->5\n```\n\n　　思路如下：\n\n　　做这道题由于代码比之前easy模式的长了很多，为了debug方便，我全程是在ipython notebook里面调试的。这道题是和单向链表(singly-linked list)相关的，为了便于调试，我们先定义好这个数据结构，以及如何初始化和可视化一个链表。简单来说，初始化就是将一个List转化为链表，可视化就是把一个链表按head->tail完整的打印出来。\n\n\n\n```python\n# Definition for singly-linked list.\n# 即定义一个单向链表里的节点，它有两个属性：节点表示的数值和指向的下一个节点\nclass ListNode(object):\n     def __init__(self, x):\n            self.val = x\n            self.next = None\n```\n```python\n# 从一个list生成一个单向链表\ndef formList(nums):\n    if not nums:\n        return None\n    head = ListNode(nums[0])\n    dummy = head\n    for num in nums[1:]:\n        head.next = ListNode(num)\n        head = head.next\n    return dummy\n\n# 将一个单向链表从head到tail将其节点数值打印出来\n# 这里是为了后面调试方便\ndef showList(head):\n    res = []\n    cur = head\n    while cur:\n        res.append(cur.val)\n        cur = cur.next\n    return res\n```\n <!-- more -->\n\n　　\n　　审题: 对于一个有 $n$ 个节点的链表，给定一个 $k$ 值，需要将每块长度为 $k$ 的子链表反向； 如果 $n%k != 0$ ，则对最后一个节点少于 $k$ 的子链表来说，不将其反向。\n\n　　\n　　因此有如下几点考虑：\n　　1. 如果链表为空或者$k<2$，或者$n<k$，则直接返回head即可；但是由于链表和list不同，不能直接取出长度，所以第三种情况需要另外考虑；\n　　2. 对于每个长度为$k$的子链表，可以考虑写一个子程序将其反向，对于每个节点，我们标记其前驱节点pre,和后续节点_next，逐个反向，得到新的head和tail；需要注意的是每个子链表的第一个和最后一个节点需要和前面和后面的子链表关联好；\n　　3. 对于第一个反向的子链表，其新的head是特别的，因为就是需要返回的新链表的head。\n　　\n\n　　\n\n  子程序如下：\n\n```python\n# 传入的参数有三个：\n# cur_head: 需要反向的当前子链表的表头\n# pre: 当前子链表的前驱节点\n# k: 子链表节点个数\n# 返回的参数也有三个：\n# new_head: 反向后子链表的表头，需要定义为pre的后继\n# cur_head:更新cur_head，即需要反向的下一个子链表的表头\n# cur_tail: 反向后子链表的最后一个节点，是下一个需要反向的子链表的pre\n\ndef rever(cur_head, pre,k):\n    new_head = cur_head\n    # 对应第一点说的第三种情况，如果子链表长度不足k，则不需要反向\n    # 反之，next k-1 次后即是新的表头\n    for i in range(k-1):\n        new_head = new_head.next\n        if not new_head:\n            return\n    \n    cur_node = cur_head\n    for i in range(k):\n        \n       # print('cur_node=',cur_node.val)\n        _next = cur_node.next\n        cur_node.next = pre\n        pre = cur_node\n        cur_node = _next\n        \n    cur_tail = cur_head\n    cur_head = cur_node\n    cur_tail.next = cur_head\n\n\n    return new_head,cur_head,cur_tail  \n```\n\n　　主程序如下：\n```python\ndef reverseKGroup(head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if not head or k<2:\n            return head\n        cur_head = head # 第一个cur_head就是链表的head\n        \n        first = rever(cur_head,None,k) # 第一次反向的子链表很特殊\n        if not first:\n            return head\n        _head,cur_head,cur_tail = first[0],first[1],first[2]\n        \n        \n        while(cur_head):\n            res = rever(cur_head,cur_tail,k)\n           \n            if res:\n                cur_tail.next = res[0]\n                cur_head = res[1]\n                cur_tail = res[2]\n            else:\n                return _head\n        return _head   \n```\n\n　　测试：\n```python\na = formList([1,2,3,4,5,6,7,8,9])\nb = formList([1,2,3,4,5,6,7,8,9])\nprint('a = b = ', showList(a))\nres_a = reverseKGroup(a,3)\nres_b = reverseKGroup(b,4)\nprint('res_a = ',showList(res_a))\nprint('res_b = ',showList(res_b))\n```\n\n　　输出：\n```python\na = b =  [1, 2, 3, 4, 5, 6, 7, 8, 9]\nres_a =  [3, 2, 1, 6, 5, 4, 9, 8, 7]\nres_b =  [4, 3, 2, 1, 8, 7, 6, 5, 9]\n```\n\n　　通过!!!\n　　当看到出现绿色的\"Accept\"时，第一次觉得绿色这么可爱。。。话不多说了，再接再厉吧，下次刷了Hard模式的再更~\n","source":"_posts/Leetcode之旅：数据结构之P25.md","raw":"---\ntitle: Leetcode之旅|链表啊，链表 (0)\ndate: 2018-01-15 21:06:37\ntags: \n    - Leetcode\n    - algorithm\n    - Data Structure\ncatogories:\n    - Leetcode\nmathjax: true\n---\n\n　　由于近期状态不太好，很久没更新博客了，惭愧三秒钟。\n\n　　今天放纵自我刷题刷了半天，本来怂怂的我只敢挑战“easy”的题，后来刷了几道linked list的题后，胆儿肥了，刷了道hard模式的题，折腾了将近两个小时，才Pass，现在一把辛酸泪地把思路给记录下来，免得忘记。\n\n  Problem 25: Reverse Nodes in k-Group\n\n  Description:\n\n  ---\n\nGiven a linked list, reverse the nodes of a linked list k at a time and return its modified list.\n\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\n\nYou may not alter the values in the nodes, only nodes itself may be changed.\n\nOnly constant memory is allowed.\n\nFor example,\n```python\nGiven this linked list: 1->2->3->4->5\n\nFor k = 2, you should return: 2->1->4->3->5\n\nFor k = 3, you should return: 3->2->1->4->5\n```\n\n　　思路如下：\n\n　　做这道题由于代码比之前easy模式的长了很多，为了debug方便，我全程是在ipython notebook里面调试的。这道题是和单向链表(singly-linked list)相关的，为了便于调试，我们先定义好这个数据结构，以及如何初始化和可视化一个链表。简单来说，初始化就是将一个List转化为链表，可视化就是把一个链表按head->tail完整的打印出来。\n\n\n\n```python\n# Definition for singly-linked list.\n# 即定义一个单向链表里的节点，它有两个属性：节点表示的数值和指向的下一个节点\nclass ListNode(object):\n     def __init__(self, x):\n            self.val = x\n            self.next = None\n```\n```python\n# 从一个list生成一个单向链表\ndef formList(nums):\n    if not nums:\n        return None\n    head = ListNode(nums[0])\n    dummy = head\n    for num in nums[1:]:\n        head.next = ListNode(num)\n        head = head.next\n    return dummy\n\n# 将一个单向链表从head到tail将其节点数值打印出来\n# 这里是为了后面调试方便\ndef showList(head):\n    res = []\n    cur = head\n    while cur:\n        res.append(cur.val)\n        cur = cur.next\n    return res\n```\n <!-- more -->\n\n　　\n　　审题: 对于一个有 $n$ 个节点的链表，给定一个 $k$ 值，需要将每块长度为 $k$ 的子链表反向； 如果 $n%k != 0$ ，则对最后一个节点少于 $k$ 的子链表来说，不将其反向。\n\n　　\n　　因此有如下几点考虑：\n　　1. 如果链表为空或者$k<2$，或者$n<k$，则直接返回head即可；但是由于链表和list不同，不能直接取出长度，所以第三种情况需要另外考虑；\n　　2. 对于每个长度为$k$的子链表，可以考虑写一个子程序将其反向，对于每个节点，我们标记其前驱节点pre,和后续节点_next，逐个反向，得到新的head和tail；需要注意的是每个子链表的第一个和最后一个节点需要和前面和后面的子链表关联好；\n　　3. 对于第一个反向的子链表，其新的head是特别的，因为就是需要返回的新链表的head。\n　　\n\n　　\n\n  子程序如下：\n\n```python\n# 传入的参数有三个：\n# cur_head: 需要反向的当前子链表的表头\n# pre: 当前子链表的前驱节点\n# k: 子链表节点个数\n# 返回的参数也有三个：\n# new_head: 反向后子链表的表头，需要定义为pre的后继\n# cur_head:更新cur_head，即需要反向的下一个子链表的表头\n# cur_tail: 反向后子链表的最后一个节点，是下一个需要反向的子链表的pre\n\ndef rever(cur_head, pre,k):\n    new_head = cur_head\n    # 对应第一点说的第三种情况，如果子链表长度不足k，则不需要反向\n    # 反之，next k-1 次后即是新的表头\n    for i in range(k-1):\n        new_head = new_head.next\n        if not new_head:\n            return\n    \n    cur_node = cur_head\n    for i in range(k):\n        \n       # print('cur_node=',cur_node.val)\n        _next = cur_node.next\n        cur_node.next = pre\n        pre = cur_node\n        cur_node = _next\n        \n    cur_tail = cur_head\n    cur_head = cur_node\n    cur_tail.next = cur_head\n\n\n    return new_head,cur_head,cur_tail  \n```\n\n　　主程序如下：\n```python\ndef reverseKGroup(head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if not head or k<2:\n            return head\n        cur_head = head # 第一个cur_head就是链表的head\n        \n        first = rever(cur_head,None,k) # 第一次反向的子链表很特殊\n        if not first:\n            return head\n        _head,cur_head,cur_tail = first[0],first[1],first[2]\n        \n        \n        while(cur_head):\n            res = rever(cur_head,cur_tail,k)\n           \n            if res:\n                cur_tail.next = res[0]\n                cur_head = res[1]\n                cur_tail = res[2]\n            else:\n                return _head\n        return _head   \n```\n\n　　测试：\n```python\na = formList([1,2,3,4,5,6,7,8,9])\nb = formList([1,2,3,4,5,6,7,8,9])\nprint('a = b = ', showList(a))\nres_a = reverseKGroup(a,3)\nres_b = reverseKGroup(b,4)\nprint('res_a = ',showList(res_a))\nprint('res_b = ',showList(res_b))\n```\n\n　　输出：\n```python\na = b =  [1, 2, 3, 4, 5, 6, 7, 8, 9]\nres_a =  [3, 2, 1, 6, 5, 4, 9, 8, 7]\nres_b =  [4, 3, 2, 1, 8, 7, 6, 5, 9]\n```\n\n　　通过!!!\n　　当看到出现绿色的\"Accept\"时，第一次觉得绿色这么可爱。。。话不多说了，再接再厉吧，下次刷了Hard模式的再更~\n","slug":"Leetcode之旅：数据结构之P25","published":1,"updated":"2018-01-18T14:21:40.172Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcknckyu0008souya53p7uzd","content":"<p>　　由于近期状态不太好，很久没更新博客了，惭愧三秒钟。</p>\n<p>　　今天放纵自我刷题刷了半天，本来怂怂的我只敢挑战“easy”的题，后来刷了几道linked list的题后，胆儿肥了，刷了道hard模式的题，折腾了将近两个小时，才Pass，现在一把辛酸泪地把思路给记录下来，免得忘记。</p>\n<p>  Problem 25: Reverse Nodes in k-Group</p>\n<p>  Description:</p>\n<hr>\n<p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p>\n<p>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p>\n<p>You may not alter the values in the nodes, only nodes itself may be changed.</p>\n<p>Only constant memory is allowed.</p>\n<p>For example,<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</span><br><span class=\"line\"></span><br><span class=\"line\">For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</span><br><span class=\"line\"></span><br><span class=\"line\">For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</span><br></pre></td></tr></table></figure></p>\n<p>　　思路如下：</p>\n<p>　　做这道题由于代码比之前easy模式的长了很多，为了debug方便，我全程是在ipython notebook里面调试的。这道题是和单向链表(singly-linked list)相关的，为了便于调试，我们先定义好这个数据结构，以及如何初始化和可视化一个链表。简单来说，初始化就是将一个List转化为链表，可视化就是把一个链表按head-&gt;tail完整的打印出来。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># 即定义一个单向链表里的节点，它有两个属性：节点表示的数值和指向的下一个节点</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListNode</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, x)</span>:</span></span><br><span class=\"line\">            self.val = x</span><br><span class=\"line\">            self.next = <span class=\"keyword\">None</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 从一个list生成一个单向链表</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">formList</span><span class=\"params\">(nums)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> nums:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">None</span></span><br><span class=\"line\">    head = ListNode(nums[<span class=\"number\">0</span>])</span><br><span class=\"line\">    dummy = head</span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums[<span class=\"number\">1</span>:]:</span><br><span class=\"line\">        head.next = ListNode(num)</span><br><span class=\"line\">        head = head.next</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dummy</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将一个单向链表从head到tail将其节点数值打印出来</span></span><br><span class=\"line\"><span class=\"comment\"># 这里是为了后面调试方便</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">showList</span><span class=\"params\">(head)</span>:</span></span><br><span class=\"line\">    res = []</span><br><span class=\"line\">    cur = head</span><br><span class=\"line\">    <span class=\"keyword\">while</span> cur:</span><br><span class=\"line\">        res.append(cur.val)</span><br><span class=\"line\">        cur = cur.next</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n <a id=\"more\"></a>\n<p>　　<br>　　审题: 对于一个有 $n$ 个节点的链表，给定一个 $k$ 值，需要将每块长度为 $k$ 的子链表反向； 如果 $n%k != 0$ ，则对最后一个节点少于 $k$ 的子链表来说，不将其反向。</p>\n<p>　　<br>　　因此有如下几点考虑：<br>　　1. 如果链表为空或者$k&lt;2$，或者$n&lt;k$，则直接返回head即可；但是由于链表和list不同，不能直接取出长度，所以第三种情况需要另外考虑；<br>　　2. 对于每个长度为$k$的子链表，可以考虑写一个子程序将其反向，对于每个节点，我们标记其前驱节点pre,和后续节点_next，逐个反向，得到新的head和tail；需要注意的是每个子链表的第一个和最后一个节点需要和前面和后面的子链表关联好；<br>　　3. 对于第一个反向的子链表，其新的head是特别的，因为就是需要返回的新链表的head。\n　　</p>\n<p>　　</p>\n<p>  子程序如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 传入的参数有三个：</span></span><br><span class=\"line\"><span class=\"comment\"># cur_head: 需要反向的当前子链表的表头</span></span><br><span class=\"line\"><span class=\"comment\"># pre: 当前子链表的前驱节点</span></span><br><span class=\"line\"><span class=\"comment\"># k: 子链表节点个数</span></span><br><span class=\"line\"><span class=\"comment\"># 返回的参数也有三个：</span></span><br><span class=\"line\"><span class=\"comment\"># new_head: 反向后子链表的表头，需要定义为pre的后继</span></span><br><span class=\"line\"><span class=\"comment\"># cur_head:更新cur_head，即需要反向的下一个子链表的表头</span></span><br><span class=\"line\"><span class=\"comment\"># cur_tail: 反向后子链表的最后一个节点，是下一个需要反向的子链表的pre</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rever</span><span class=\"params\">(cur_head, pre,k)</span>:</span></span><br><span class=\"line\">    new_head = cur_head</span><br><span class=\"line\">    <span class=\"comment\"># 对应第一点说的第三种情况，如果子链表长度不足k，则不需要反向</span></span><br><span class=\"line\">    <span class=\"comment\"># 反之，next k-1 次后即是新的表头</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(k<span class=\"number\">-1</span>):</span><br><span class=\"line\">        new_head = new_head.next</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> new_head:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    cur_node = cur_head</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(k):</span><br><span class=\"line\">        </span><br><span class=\"line\">       <span class=\"comment\"># print('cur_node=',cur_node.val)</span></span><br><span class=\"line\">        _next = cur_node.next</span><br><span class=\"line\">        cur_node.next = pre</span><br><span class=\"line\">        pre = cur_node</span><br><span class=\"line\">        cur_node = _next</span><br><span class=\"line\">        </span><br><span class=\"line\">    cur_tail = cur_head</span><br><span class=\"line\">    cur_head = cur_node</span><br><span class=\"line\">    cur_tail.next = cur_head</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> new_head,cur_head,cur_tail</span><br></pre></td></tr></table></figure>\n<p>　　主程序如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseKGroup</span><span class=\"params\">(head, k)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type head: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :type k: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> head <span class=\"keyword\">or</span> k&lt;<span class=\"number\">2</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head</span><br><span class=\"line\">        cur_head = head <span class=\"comment\"># 第一个cur_head就是链表的head</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        first = rever(cur_head,<span class=\"keyword\">None</span>,k) <span class=\"comment\"># 第一次反向的子链表很特殊</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> first:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head</span><br><span class=\"line\">        _head,cur_head,cur_tail = first[<span class=\"number\">0</span>],first[<span class=\"number\">1</span>],first[<span class=\"number\">2</span>]</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur_head):</span><br><span class=\"line\">            res = rever(cur_head,cur_tail,k)</span><br><span class=\"line\">           </span><br><span class=\"line\">            <span class=\"keyword\">if</span> res:</span><br><span class=\"line\">                cur_tail.next = res[<span class=\"number\">0</span>]</span><br><span class=\"line\">                cur_head = res[<span class=\"number\">1</span>]</span><br><span class=\"line\">                cur_tail = res[<span class=\"number\">2</span>]</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> _head</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _head</span><br></pre></td></tr></table></figure></p>\n<p>　　测试：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = formList([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>])</span><br><span class=\"line\">b = formList([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>])</span><br><span class=\"line\">print(<span class=\"string\">'a = b = '</span>, showList(a))</span><br><span class=\"line\">res_a = reverseKGroup(a,<span class=\"number\">3</span>)</span><br><span class=\"line\">res_b = reverseKGroup(b,<span class=\"number\">4</span>)</span><br><span class=\"line\">print(<span class=\"string\">'res_a = '</span>,showList(res_a))</span><br><span class=\"line\">print(<span class=\"string\">'res_b = '</span>,showList(res_b))</span><br></pre></td></tr></table></figure></p>\n<p>　　输出：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = b =  [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>]</span><br><span class=\"line\">res_a =  [<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">6</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">8</span>, <span class=\"number\">7</span>]</span><br><span class=\"line\">res_b =  [<span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">8</span>, <span class=\"number\">7</span>, <span class=\"number\">6</span>, <span class=\"number\">5</span>, <span class=\"number\">9</span>]</span><br></pre></td></tr></table></figure></p>\n<p>　　通过!!!<br>　　当看到出现绿色的”Accept”时，第一次觉得绿色这么可爱。。。话不多说了，再接再厉吧，下次刷了Hard模式的再更~</p>\n","site":{"data":{}},"excerpt":"<p>　　由于近期状态不太好，很久没更新博客了，惭愧三秒钟。</p>\n<p>　　今天放纵自我刷题刷了半天，本来怂怂的我只敢挑战“easy”的题，后来刷了几道linked list的题后，胆儿肥了，刷了道hard模式的题，折腾了将近两个小时，才Pass，现在一把辛酸泪地把思路给记录下来，免得忘记。</p>\n<p>  Problem 25: Reverse Nodes in k-Group</p>\n<p>  Description:</p>\n<hr>\n<p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p>\n<p>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p>\n<p>You may not alter the values in the nodes, only nodes itself may be changed.</p>\n<p>Only constant memory is allowed.</p>\n<p>For example,<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</span><br><span class=\"line\"></span><br><span class=\"line\">For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</span><br><span class=\"line\"></span><br><span class=\"line\">For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</span><br></pre></td></tr></table></figure></p>\n<p>　　思路如下：</p>\n<p>　　做这道题由于代码比之前easy模式的长了很多，为了debug方便，我全程是在ipython notebook里面调试的。这道题是和单向链表(singly-linked list)相关的，为了便于调试，我们先定义好这个数据结构，以及如何初始化和可视化一个链表。简单来说，初始化就是将一个List转化为链表，可视化就是把一个链表按head-&gt;tail完整的打印出来。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># 即定义一个单向链表里的节点，它有两个属性：节点表示的数值和指向的下一个节点</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListNode</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, x)</span>:</span></span><br><span class=\"line\">            self.val = x</span><br><span class=\"line\">            self.next = <span class=\"keyword\">None</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 从一个list生成一个单向链表</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">formList</span><span class=\"params\">(nums)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> nums:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">None</span></span><br><span class=\"line\">    head = ListNode(nums[<span class=\"number\">0</span>])</span><br><span class=\"line\">    dummy = head</span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums[<span class=\"number\">1</span>:]:</span><br><span class=\"line\">        head.next = ListNode(num)</span><br><span class=\"line\">        head = head.next</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dummy</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将一个单向链表从head到tail将其节点数值打印出来</span></span><br><span class=\"line\"><span class=\"comment\"># 这里是为了后面调试方便</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">showList</span><span class=\"params\">(head)</span>:</span></span><br><span class=\"line\">    res = []</span><br><span class=\"line\">    cur = head</span><br><span class=\"line\">    <span class=\"keyword\">while</span> cur:</span><br><span class=\"line\">        res.append(cur.val)</span><br><span class=\"line\">        cur = cur.next</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>","more":"<p>　　<br>　　审题: 对于一个有 $n$ 个节点的链表，给定一个 $k$ 值，需要将每块长度为 $k$ 的子链表反向； 如果 $n%k != 0$ ，则对最后一个节点少于 $k$ 的子链表来说，不将其反向。</p>\n<p>　　<br>　　因此有如下几点考虑：<br>　　1. 如果链表为空或者$k&lt;2$，或者$n&lt;k$，则直接返回head即可；但是由于链表和list不同，不能直接取出长度，所以第三种情况需要另外考虑；<br>　　2. 对于每个长度为$k$的子链表，可以考虑写一个子程序将其反向，对于每个节点，我们标记其前驱节点pre,和后续节点_next，逐个反向，得到新的head和tail；需要注意的是每个子链表的第一个和最后一个节点需要和前面和后面的子链表关联好；<br>　　3. 对于第一个反向的子链表，其新的head是特别的，因为就是需要返回的新链表的head。\n　　</p>\n<p>　　</p>\n<p>  子程序如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 传入的参数有三个：</span></span><br><span class=\"line\"><span class=\"comment\"># cur_head: 需要反向的当前子链表的表头</span></span><br><span class=\"line\"><span class=\"comment\"># pre: 当前子链表的前驱节点</span></span><br><span class=\"line\"><span class=\"comment\"># k: 子链表节点个数</span></span><br><span class=\"line\"><span class=\"comment\"># 返回的参数也有三个：</span></span><br><span class=\"line\"><span class=\"comment\"># new_head: 反向后子链表的表头，需要定义为pre的后继</span></span><br><span class=\"line\"><span class=\"comment\"># cur_head:更新cur_head，即需要反向的下一个子链表的表头</span></span><br><span class=\"line\"><span class=\"comment\"># cur_tail: 反向后子链表的最后一个节点，是下一个需要反向的子链表的pre</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rever</span><span class=\"params\">(cur_head, pre,k)</span>:</span></span><br><span class=\"line\">    new_head = cur_head</span><br><span class=\"line\">    <span class=\"comment\"># 对应第一点说的第三种情况，如果子链表长度不足k，则不需要反向</span></span><br><span class=\"line\">    <span class=\"comment\"># 反之，next k-1 次后即是新的表头</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(k<span class=\"number\">-1</span>):</span><br><span class=\"line\">        new_head = new_head.next</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> new_head:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    cur_node = cur_head</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(k):</span><br><span class=\"line\">        </span><br><span class=\"line\">       <span class=\"comment\"># print('cur_node=',cur_node.val)</span></span><br><span class=\"line\">        _next = cur_node.next</span><br><span class=\"line\">        cur_node.next = pre</span><br><span class=\"line\">        pre = cur_node</span><br><span class=\"line\">        cur_node = _next</span><br><span class=\"line\">        </span><br><span class=\"line\">    cur_tail = cur_head</span><br><span class=\"line\">    cur_head = cur_node</span><br><span class=\"line\">    cur_tail.next = cur_head</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> new_head,cur_head,cur_tail</span><br></pre></td></tr></table></figure>\n<p>　　主程序如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseKGroup</span><span class=\"params\">(head, k)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type head: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :type k: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> head <span class=\"keyword\">or</span> k&lt;<span class=\"number\">2</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head</span><br><span class=\"line\">        cur_head = head <span class=\"comment\"># 第一个cur_head就是链表的head</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        first = rever(cur_head,<span class=\"keyword\">None</span>,k) <span class=\"comment\"># 第一次反向的子链表很特殊</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> first:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head</span><br><span class=\"line\">        _head,cur_head,cur_tail = first[<span class=\"number\">0</span>],first[<span class=\"number\">1</span>],first[<span class=\"number\">2</span>]</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur_head):</span><br><span class=\"line\">            res = rever(cur_head,cur_tail,k)</span><br><span class=\"line\">           </span><br><span class=\"line\">            <span class=\"keyword\">if</span> res:</span><br><span class=\"line\">                cur_tail.next = res[<span class=\"number\">0</span>]</span><br><span class=\"line\">                cur_head = res[<span class=\"number\">1</span>]</span><br><span class=\"line\">                cur_tail = res[<span class=\"number\">2</span>]</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> _head</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _head</span><br></pre></td></tr></table></figure></p>\n<p>　　测试：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = formList([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>])</span><br><span class=\"line\">b = formList([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>])</span><br><span class=\"line\">print(<span class=\"string\">'a = b = '</span>, showList(a))</span><br><span class=\"line\">res_a = reverseKGroup(a,<span class=\"number\">3</span>)</span><br><span class=\"line\">res_b = reverseKGroup(b,<span class=\"number\">4</span>)</span><br><span class=\"line\">print(<span class=\"string\">'res_a = '</span>,showList(res_a))</span><br><span class=\"line\">print(<span class=\"string\">'res_b = '</span>,showList(res_b))</span><br></pre></td></tr></table></figure></p>\n<p>　　输出：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = b =  [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>]</span><br><span class=\"line\">res_a =  [<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">6</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">8</span>, <span class=\"number\">7</span>]</span><br><span class=\"line\">res_b =  [<span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">8</span>, <span class=\"number\">7</span>, <span class=\"number\">6</span>, <span class=\"number\">5</span>, <span class=\"number\">9</span>]</span><br></pre></td></tr></table></figure></p>\n<p>　　通过!!!<br>　　当看到出现绿色的”Accept”时，第一次觉得绿色这么可爱。。。话不多说了，再接再厉吧，下次刷了Hard模式的再更~</p>"},{"title":"最近英语学习的一点心得","date":"2017-09-21T13:26:54.000Z","_content":"\n最近因为工作后换了环境，发现平时很少用英语，有点担心会在需要点亮英语技能树的时候才发现“技到用时方恨少”，所以决定接受知乎的安利，拜读一下《Word Power Made Easy》这本传说中的神书。\n\n![祭出神书封面](https://img3.doubanio.com/lpic/s6525336.jpg)\n\n由于最近刚写了篇还算比较长的review，给了同事一种我英语很好的错觉，但其实我很惭愧，因为我英语其实并没有那么好，很多时候需要写或者需要说的时候都发现自己很束手无策。尤其是目前这本书看了前六章，觉得触动很大。\n\n<!-- more -->\n1. 词根词缀\n----  \n\n其实之前觉得靠词根词缀法记忆单词很扯，因为很多词根词缀的在不同词的样子都是不同的，而有些单词里看着像词根词缀的其实又不是词根词缀（有种freestyle的感觉。。。）。但看了这本书，因为它介绍了词根的来源，原来大部分词根其实都来自于希腊语或者拉丁语，举个栗子，calligraphy，来源于希腊语kallo(beauty)和graphein(to write),合在一起就是beautiful writing(书法)的意思。再比如我们很熟悉的disaster，就是来源于astron,意思是star，古人认为星星主宰着人类的命运，而前缀dis-这里的意思是against的意思，合起来就是不幸，灾难的意思 （没想到这么个简单的词汇起源是这个）。\n\n所以看了这些词汇的起源确实在平时的阅读中会想更多，比如读一篇文章，就会发现，啊这个词原来是来源于这个词汇，而另一个不认识的词汇可能根据知道的某些词根词缀和适当的变型，大概也能猜出是什么意思。所以，平时读些词根起源还是挺有意思的，就当学单词的偏旁部首了，而且还能学习一些有趣的小故事，比如，Bellona是罗马神话里的女战神，所以bell-现在作为词根就代表了“战争”的意思。\n\n2. 语法\n----\n\n语法部分目前看的还不多，但有句话印象很深刻：\n> Gramma follows the speech habits of the majority of educated people--not the other way around.\n\n\n有人说，其实在口语中，和native speaker交流其实对方并不关注我们的语法是否正确，但其实错得太离谱也是会影响表达的；而平时的英语写作中，语法的作用可能是为了让我们更精准地传达我们的想法。有点时候，less than more，越精简可能越有力量。同时，语法也不是一成不变的，但总是educated people说了算（知识就是力量啊。。。）。\n\n3. 表达\n----\n这点其实是最近听了一些歌剧和Keats的诗歌是时候发现的。不需要多说什么，随便举几个例子，就能感受到英语的美感：\n\n比如歌剧《基督山伯爵》中的：\n\n> When you lift your gaze, \n> \n> I will be like a shimmer of one small star, \n> \n> out there, \n> \n> shining everywhere.\n> \n>------《I will be there》 From 《The Count Of Monte Cristo》   \n\n再比如歌剧《日落大道》的：\n\n> With one look I put words to shame,\n> \n> Just one look sets the screen aflame\n> \n> Silent Music starts to play\n> \n> One tear in my eye makes the whole world cry\n> \n> with one look they'll forgive the past.\n> \n> ------《With one look》 From 《Sunset Boulevard》\n  \n\n再比如情圣济慈的酥耳朵情话（由抖森来读感觉听着耳朵要怀孕）：\n\n> I want a brighter word whan bright, a fairer word an fair.\n> \n> I almost wish we were butterflies and lived but three summer days. Three such days with you I could fill with more delight than 50 common years could ever contain.\n> \n>  \n>   -----Keats\n\n\n   \n4. 小结\n---\n可见学英语还是很有意思且必要呀，嗯，加油。\n","source":"_posts/最近英语学习的一点心得.md","raw":"---\ntitle: 最近英语学习的一点心得\ndate: 2017-09-21 21:26:54\ntags: \n    - 随笔\n    - 英语学习\n    - 读书笔记 \ncategories:\n    - 英语学习\n---\n\n最近因为工作后换了环境，发现平时很少用英语，有点担心会在需要点亮英语技能树的时候才发现“技到用时方恨少”，所以决定接受知乎的安利，拜读一下《Word Power Made Easy》这本传说中的神书。\n\n![祭出神书封面](https://img3.doubanio.com/lpic/s6525336.jpg)\n\n由于最近刚写了篇还算比较长的review，给了同事一种我英语很好的错觉，但其实我很惭愧，因为我英语其实并没有那么好，很多时候需要写或者需要说的时候都发现自己很束手无策。尤其是目前这本书看了前六章，觉得触动很大。\n\n<!-- more -->\n1. 词根词缀\n----  \n\n其实之前觉得靠词根词缀法记忆单词很扯，因为很多词根词缀的在不同词的样子都是不同的，而有些单词里看着像词根词缀的其实又不是词根词缀（有种freestyle的感觉。。。）。但看了这本书，因为它介绍了词根的来源，原来大部分词根其实都来自于希腊语或者拉丁语，举个栗子，calligraphy，来源于希腊语kallo(beauty)和graphein(to write),合在一起就是beautiful writing(书法)的意思。再比如我们很熟悉的disaster，就是来源于astron,意思是star，古人认为星星主宰着人类的命运，而前缀dis-这里的意思是against的意思，合起来就是不幸，灾难的意思 （没想到这么个简单的词汇起源是这个）。\n\n所以看了这些词汇的起源确实在平时的阅读中会想更多，比如读一篇文章，就会发现，啊这个词原来是来源于这个词汇，而另一个不认识的词汇可能根据知道的某些词根词缀和适当的变型，大概也能猜出是什么意思。所以，平时读些词根起源还是挺有意思的，就当学单词的偏旁部首了，而且还能学习一些有趣的小故事，比如，Bellona是罗马神话里的女战神，所以bell-现在作为词根就代表了“战争”的意思。\n\n2. 语法\n----\n\n语法部分目前看的还不多，但有句话印象很深刻：\n> Gramma follows the speech habits of the majority of educated people--not the other way around.\n\n\n有人说，其实在口语中，和native speaker交流其实对方并不关注我们的语法是否正确，但其实错得太离谱也是会影响表达的；而平时的英语写作中，语法的作用可能是为了让我们更精准地传达我们的想法。有点时候，less than more，越精简可能越有力量。同时，语法也不是一成不变的，但总是educated people说了算（知识就是力量啊。。。）。\n\n3. 表达\n----\n这点其实是最近听了一些歌剧和Keats的诗歌是时候发现的。不需要多说什么，随便举几个例子，就能感受到英语的美感：\n\n比如歌剧《基督山伯爵》中的：\n\n> When you lift your gaze, \n> \n> I will be like a shimmer of one small star, \n> \n> out there, \n> \n> shining everywhere.\n> \n>------《I will be there》 From 《The Count Of Monte Cristo》   \n\n再比如歌剧《日落大道》的：\n\n> With one look I put words to shame,\n> \n> Just one look sets the screen aflame\n> \n> Silent Music starts to play\n> \n> One tear in my eye makes the whole world cry\n> \n> with one look they'll forgive the past.\n> \n> ------《With one look》 From 《Sunset Boulevard》\n  \n\n再比如情圣济慈的酥耳朵情话（由抖森来读感觉听着耳朵要怀孕）：\n\n> I want a brighter word whan bright, a fairer word an fair.\n> \n> I almost wish we were butterflies and lived but three summer days. Three such days with you I could fill with more delight than 50 common years could ever contain.\n> \n>  \n>   -----Keats\n\n\n   \n4. 小结\n---\n可见学英语还是很有意思且必要呀，嗯，加油。\n","slug":"最近英语学习的一点心得","published":1,"updated":"2018-01-16T03:43:02.894Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcknckyu0009souy8ok0uefl","content":"<p>最近因为工作后换了环境，发现平时很少用英语，有点担心会在需要点亮英语技能树的时候才发现“技到用时方恨少”，所以决定接受知乎的安利，拜读一下《Word Power Made Easy》这本传说中的神书。</p>\n<p><img src=\"https://img3.doubanio.com/lpic/s6525336.jpg\" alt=\"祭出神书封面\"></p>\n<p>由于最近刚写了篇还算比较长的review，给了同事一种我英语很好的错觉，但其实我很惭愧，因为我英语其实并没有那么好，很多时候需要写或者需要说的时候都发现自己很束手无策。尤其是目前这本书看了前六章，觉得触动很大。</p>\n<a id=\"more\"></a>\n<h2 id=\"1-词根词缀\"><a href=\"#1-词根词缀\" class=\"headerlink\" title=\"1. 词根词缀\"></a>1. 词根词缀</h2><p>其实之前觉得靠词根词缀法记忆单词很扯，因为很多词根词缀的在不同词的样子都是不同的，而有些单词里看着像词根词缀的其实又不是词根词缀（有种freestyle的感觉。。。）。但看了这本书，因为它介绍了词根的来源，原来大部分词根其实都来自于希腊语或者拉丁语，举个栗子，calligraphy，来源于希腊语kallo(beauty)和graphein(to write),合在一起就是beautiful writing(书法)的意思。再比如我们很熟悉的disaster，就是来源于astron,意思是star，古人认为星星主宰着人类的命运，而前缀dis-这里的意思是against的意思，合起来就是不幸，灾难的意思 （没想到这么个简单的词汇起源是这个）。</p>\n<p>所以看了这些词汇的起源确实在平时的阅读中会想更多，比如读一篇文章，就会发现，啊这个词原来是来源于这个词汇，而另一个不认识的词汇可能根据知道的某些词根词缀和适当的变型，大概也能猜出是什么意思。所以，平时读些词根起源还是挺有意思的，就当学单词的偏旁部首了，而且还能学习一些有趣的小故事，比如，Bellona是罗马神话里的女战神，所以bell-现在作为词根就代表了“战争”的意思。</p>\n<h2 id=\"2-语法\"><a href=\"#2-语法\" class=\"headerlink\" title=\"2. 语法\"></a>2. 语法</h2><p>语法部分目前看的还不多，但有句话印象很深刻：</p>\n<blockquote>\n<p>Gramma follows the speech habits of the majority of educated people—not the other way around.</p>\n</blockquote>\n<p>有人说，其实在口语中，和native speaker交流其实对方并不关注我们的语法是否正确，但其实错得太离谱也是会影响表达的；而平时的英语写作中，语法的作用可能是为了让我们更精准地传达我们的想法。有点时候，less than more，越精简可能越有力量。同时，语法也不是一成不变的，但总是educated people说了算（知识就是力量啊。。。）。</p>\n<h2 id=\"3-表达\"><a href=\"#3-表达\" class=\"headerlink\" title=\"3. 表达\"></a>3. 表达</h2><p>这点其实是最近听了一些歌剧和Keats的诗歌是时候发现的。不需要多说什么，随便举几个例子，就能感受到英语的美感：</p>\n<p>比如歌剧《基督山伯爵》中的：</p>\n<blockquote>\n<p>When you lift your gaze, </p>\n<p>I will be like a shimmer of one small star, </p>\n<p>out there, </p>\n<p>shining everywhere.</p>\n<p>———《I will be there》 From 《The Count Of Monte Cristo》   </p>\n</blockquote>\n<p>再比如歌剧《日落大道》的：</p>\n<blockquote>\n<p>With one look I put words to shame,</p>\n<p>Just one look sets the screen aflame</p>\n<p>Silent Music starts to play</p>\n<p>One tear in my eye makes the whole world cry</p>\n<p>with one look they’ll forgive the past.</p>\n<p>———《With one look》 From 《Sunset Boulevard》</p>\n</blockquote>\n<p>再比如情圣济慈的酥耳朵情话（由抖森来读感觉听着耳朵要怀孕）：</p>\n<blockquote>\n<p>I want a brighter word whan bright, a fairer word an fair.</p>\n<p>I almost wish we were butterflies and lived but three summer days. Three such days with you I could fill with more delight than 50 common years could ever contain.</p>\n<p>  ——-Keats</p>\n</blockquote>\n<h2 id=\"4-小结\"><a href=\"#4-小结\" class=\"headerlink\" title=\"4. 小结\"></a>4. 小结</h2><p>可见学英语还是很有意思且必要呀，嗯，加油。</p>\n","site":{"data":{}},"excerpt":"<p>最近因为工作后换了环境，发现平时很少用英语，有点担心会在需要点亮英语技能树的时候才发现“技到用时方恨少”，所以决定接受知乎的安利，拜读一下《Word Power Made Easy》这本传说中的神书。</p>\n<p><img src=\"https://img3.doubanio.com/lpic/s6525336.jpg\" alt=\"祭出神书封面\"></p>\n<p>由于最近刚写了篇还算比较长的review，给了同事一种我英语很好的错觉，但其实我很惭愧，因为我英语其实并没有那么好，很多时候需要写或者需要说的时候都发现自己很束手无策。尤其是目前这本书看了前六章，觉得触动很大。</p>","more":"<h2 id=\"1-词根词缀\"><a href=\"#1-词根词缀\" class=\"headerlink\" title=\"1. 词根词缀\"></a>1. 词根词缀</h2><p>其实之前觉得靠词根词缀法记忆单词很扯，因为很多词根词缀的在不同词的样子都是不同的，而有些单词里看着像词根词缀的其实又不是词根词缀（有种freestyle的感觉。。。）。但看了这本书，因为它介绍了词根的来源，原来大部分词根其实都来自于希腊语或者拉丁语，举个栗子，calligraphy，来源于希腊语kallo(beauty)和graphein(to write),合在一起就是beautiful writing(书法)的意思。再比如我们很熟悉的disaster，就是来源于astron,意思是star，古人认为星星主宰着人类的命运，而前缀dis-这里的意思是against的意思，合起来就是不幸，灾难的意思 （没想到这么个简单的词汇起源是这个）。</p>\n<p>所以看了这些词汇的起源确实在平时的阅读中会想更多，比如读一篇文章，就会发现，啊这个词原来是来源于这个词汇，而另一个不认识的词汇可能根据知道的某些词根词缀和适当的变型，大概也能猜出是什么意思。所以，平时读些词根起源还是挺有意思的，就当学单词的偏旁部首了，而且还能学习一些有趣的小故事，比如，Bellona是罗马神话里的女战神，所以bell-现在作为词根就代表了“战争”的意思。</p>\n<h2 id=\"2-语法\"><a href=\"#2-语法\" class=\"headerlink\" title=\"2. 语法\"></a>2. 语法</h2><p>语法部分目前看的还不多，但有句话印象很深刻：</p>\n<blockquote>\n<p>Gramma follows the speech habits of the majority of educated people—not the other way around.</p>\n</blockquote>\n<p>有人说，其实在口语中，和native speaker交流其实对方并不关注我们的语法是否正确，但其实错得太离谱也是会影响表达的；而平时的英语写作中，语法的作用可能是为了让我们更精准地传达我们的想法。有点时候，less than more，越精简可能越有力量。同时，语法也不是一成不变的，但总是educated people说了算（知识就是力量啊。。。）。</p>\n<h2 id=\"3-表达\"><a href=\"#3-表达\" class=\"headerlink\" title=\"3. 表达\"></a>3. 表达</h2><p>这点其实是最近听了一些歌剧和Keats的诗歌是时候发现的。不需要多说什么，随便举几个例子，就能感受到英语的美感：</p>\n<p>比如歌剧《基督山伯爵》中的：</p>\n<blockquote>\n<p>When you lift your gaze, </p>\n<p>I will be like a shimmer of one small star, </p>\n<p>out there, </p>\n<p>shining everywhere.</p>\n<p>———《I will be there》 From 《The Count Of Monte Cristo》   </p>\n</blockquote>\n<p>再比如歌剧《日落大道》的：</p>\n<blockquote>\n<p>With one look I put words to shame,</p>\n<p>Just one look sets the screen aflame</p>\n<p>Silent Music starts to play</p>\n<p>One tear in my eye makes the whole world cry</p>\n<p>with one look they’ll forgive the past.</p>\n<p>———《With one look》 From 《Sunset Boulevard》</p>\n</blockquote>\n<p>再比如情圣济慈的酥耳朵情话（由抖森来读感觉听着耳朵要怀孕）：</p>\n<blockquote>\n<p>I want a brighter word whan bright, a fairer word an fair.</p>\n<p>I almost wish we were butterflies and lived but three summer days. Three such days with you I could fill with more delight than 50 common years could ever contain.</p>\n<p>  ——-Keats</p>\n</blockquote>\n<h2 id=\"4-小结\"><a href=\"#4-小结\" class=\"headerlink\" title=\"4. 小结\"></a>4. 小结</h2><p>可见学英语还是很有意思且必要呀，嗯，加油。</p>"},{"title":"让矩阵计算说人话~","date":"2017-11-10T15:30:29.000Z","mathjax":true,"_content":"\n　　刚刚想把之前在办公室电脑上更新的文件deploy上去发现总是error,但在本地服务器上看又是没错的，后来发现重新hexo clean后再hexo g -d，问题就解决了，看来重启经常能解决问题^_^\n\n　　自从打定主意重新换方向开始后看书就发现，经常会被一大堆的矩阵分析晃花了眼，真后悔当年大学没好好学习这门课，貌似线性代数都因为在我转专业之后补修的，其实就去考了个试，相当于啥也没学嘛。。。。被折磨了这么久之后，我决定整理下目前接触到一些常用的小trick，对于我来说就是把数学符号翻译成大白话。开始~~~\n\n　　首先介绍一下待会要用到的一些概念：\n\n1. $1_k$:表示$k\\times 1$的全1列向量；\n2. $x=[x_1,x_2,...,x_D]^T$:$D\\times 1$的列向量,类似的有列向量$y$;\n3. $A=[a_1,a_2,...,a_D]$:表示$D\\times D$的方阵，其中$a_i$表示$A$的第$i$列；\n4. $B=[a_1,a_2,...,a_N]$:表示$D\\times N$的矩阵，其中$a_i$表示$B$的第$i$列；\n\n\n好的，下面解释一下一些矩阵计算是在干嘛，让矩阵计算说人话吧！\n\n1. $x^Ty$:内积，也就是$x_1y_1+x_2y_2+...+x_Dy_D$,当$x=y$时，就是对$x$中所有元素求平方和；以后看到这种长相的计算都应该在脑子里想到矮宽的括号和瘦高的括号相乘后变成一个标量的场景。\n\n2. $yx^T=[x_1y,x_2y,...,x_Dy]=C$:即$C$的每一列$c_i$等于$x_iy$，相当于把$y$按照不同的系数平铺成一个矩阵，所以以后看到瘦高和矮宽结合就应该想到这个；\n\n3. $x1_k^T=\\underbrace {[x_i, ..., x_i]}_k$:相当于matlab里的```repmat(x,1,k)```，也就是把$x$复制$k$列，然后拼成一个矩阵；\n\n4. $B1_N$：对矩阵的每行求和后变为一个列向量；\n\n5. $1_D^TB$：对矩阵每列求和后变为一个行向量；\n\n6. $1_D^T B 1_N$：对矩阵所有元素求和；\n\n7. $Ax=a_1x_1+a_2x_2+...+a_Dx_D$,相当于$A$的每一列$a_i$通过对应的$x_i$值进行加权后相加得到,其中$A$可以不是方阵；\n\n8. $AB=E$,$A$的第$i$列$a_i$和$B$的第$i$行$b_i$相乘得到$e_i=a_ib_i$，$e_i$是与X相同维度的矩阵($D\\times N$),$E=\\sum e_i$，就是把$D$个矩阵求和。也就是说，$A$的每一列按照2中加权平铺，所有列按照不同的加权行平铺后，再将所有矩阵叠加。\n\n9. 第八点也可以这么想，先和第7点一样，$A$的每一列被$B$的每一列加权相加得到的列向量平铺开。\n\n\n　　暂时想到这么多~以后遇到新的再加更~~刚刚双十一买了个耳机，貌似是第一次双十一等零点买东西，期待哇咔咔~\n\n","source":"_posts/矩阵计算的小糖果.md","raw":"---\ntitle: 让矩阵计算说人话~\ndate: 2017-11-10 23:30:29\ntags: \n    - 机器学习\n    - 读书笔记\nmathjax: true\n---\n\n　　刚刚想把之前在办公室电脑上更新的文件deploy上去发现总是error,但在本地服务器上看又是没错的，后来发现重新hexo clean后再hexo g -d，问题就解决了，看来重启经常能解决问题^_^\n\n　　自从打定主意重新换方向开始后看书就发现，经常会被一大堆的矩阵分析晃花了眼，真后悔当年大学没好好学习这门课，貌似线性代数都因为在我转专业之后补修的，其实就去考了个试，相当于啥也没学嘛。。。。被折磨了这么久之后，我决定整理下目前接触到一些常用的小trick，对于我来说就是把数学符号翻译成大白话。开始~~~\n\n　　首先介绍一下待会要用到的一些概念：\n\n1. $1_k$:表示$k\\times 1$的全1列向量；\n2. $x=[x_1,x_2,...,x_D]^T$:$D\\times 1$的列向量,类似的有列向量$y$;\n3. $A=[a_1,a_2,...,a_D]$:表示$D\\times D$的方阵，其中$a_i$表示$A$的第$i$列；\n4. $B=[a_1,a_2,...,a_N]$:表示$D\\times N$的矩阵，其中$a_i$表示$B$的第$i$列；\n\n\n好的，下面解释一下一些矩阵计算是在干嘛，让矩阵计算说人话吧！\n\n1. $x^Ty$:内积，也就是$x_1y_1+x_2y_2+...+x_Dy_D$,当$x=y$时，就是对$x$中所有元素求平方和；以后看到这种长相的计算都应该在脑子里想到矮宽的括号和瘦高的括号相乘后变成一个标量的场景。\n\n2. $yx^T=[x_1y,x_2y,...,x_Dy]=C$:即$C$的每一列$c_i$等于$x_iy$，相当于把$y$按照不同的系数平铺成一个矩阵，所以以后看到瘦高和矮宽结合就应该想到这个；\n\n3. $x1_k^T=\\underbrace {[x_i, ..., x_i]}_k$:相当于matlab里的```repmat(x,1,k)```，也就是把$x$复制$k$列，然后拼成一个矩阵；\n\n4. $B1_N$：对矩阵的每行求和后变为一个列向量；\n\n5. $1_D^TB$：对矩阵每列求和后变为一个行向量；\n\n6. $1_D^T B 1_N$：对矩阵所有元素求和；\n\n7. $Ax=a_1x_1+a_2x_2+...+a_Dx_D$,相当于$A$的每一列$a_i$通过对应的$x_i$值进行加权后相加得到,其中$A$可以不是方阵；\n\n8. $AB=E$,$A$的第$i$列$a_i$和$B$的第$i$行$b_i$相乘得到$e_i=a_ib_i$，$e_i$是与X相同维度的矩阵($D\\times N$),$E=\\sum e_i$，就是把$D$个矩阵求和。也就是说，$A$的每一列按照2中加权平铺，所有列按照不同的加权行平铺后，再将所有矩阵叠加。\n\n9. 第八点也可以这么想，先和第7点一样，$A$的每一列被$B$的每一列加权相加得到的列向量平铺开。\n\n\n　　暂时想到这么多~以后遇到新的再加更~~刚刚双十一买了个耳机，貌似是第一次双十一等零点买东西，期待哇咔咔~\n\n","slug":"矩阵计算的小糖果","published":1,"updated":"2018-01-16T03:43:02.895Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcknckza000bsouyloj29ai7","content":"<p>　　刚刚想把之前在办公室电脑上更新的文件deploy上去发现总是error,但在本地服务器上看又是没错的，后来发现重新hexo clean后再hexo g -d，问题就解决了，看来重启经常能解决问题^_^</p>\n<p>　　自从打定主意重新换方向开始后看书就发现，经常会被一大堆的矩阵分析晃花了眼，真后悔当年大学没好好学习这门课，貌似线性代数都因为在我转专业之后补修的，其实就去考了个试，相当于啥也没学嘛。。。。被折磨了这么久之后，我决定整理下目前接触到一些常用的小trick，对于我来说就是把数学符号翻译成大白话。开始~~~</p>\n<p>　　首先介绍一下待会要用到的一些概念：</p>\n<ol>\n<li>$1_k$:表示$k\\times 1$的全1列向量；</li>\n<li>$x=[x_1,x_2,…,x_D]^T$:$D\\times 1$的列向量,类似的有列向量$y$;</li>\n<li>$A=[a_1,a_2,…,a_D]$:表示$D\\times D$的方阵，其中$a_i$表示$A$的第$i$列；</li>\n<li>$B=[a_1,a_2,…,a_N]$:表示$D\\times N$的矩阵，其中$a_i$表示$B$的第$i$列；</li>\n</ol>\n<p>好的，下面解释一下一些矩阵计算是在干嘛，让矩阵计算说人话吧！</p>\n<ol>\n<li><p>$x^Ty$:内积，也就是$x_1y_1+x_2y_2+…+x_Dy_D$,当$x=y$时，就是对$x$中所有元素求平方和；以后看到这种长相的计算都应该在脑子里想到矮宽的括号和瘦高的括号相乘后变成一个标量的场景。</p>\n</li>\n<li><p>$yx^T=[x_1y,x_2y,…,x_Dy]=C$:即$C$的每一列$c_i$等于$x_iy$，相当于把$y$按照不同的系数平铺成一个矩阵，所以以后看到瘦高和矮宽结合就应该想到这个；</p>\n</li>\n<li><p>$x1_k^T=\\underbrace {[x_i, …, x_i]}_k$:相当于matlab里的<code>repmat(x,1,k)</code>，也就是把$x$复制$k$列，然后拼成一个矩阵；</p>\n</li>\n<li><p>$B1_N$：对矩阵的每行求和后变为一个列向量；</p>\n</li>\n<li><p>$1_D^TB$：对矩阵每列求和后变为一个行向量；</p>\n</li>\n<li><p>$1_D^T B 1_N$：对矩阵所有元素求和；</p>\n</li>\n<li><p>$Ax=a_1x_1+a_2x_2+…+a_Dx_D$,相当于$A$的每一列$a_i$通过对应的$x_i$值进行加权后相加得到,其中$A$可以不是方阵；</p>\n</li>\n<li><p>$AB=E$,$A$的第$i$列$a_i$和$B$的第$i$行$b_i$相乘得到$e_i=a_ib_i$，$e_i$是与X相同维度的矩阵($D\\times N$),$E=\\sum e_i$，就是把$D$个矩阵求和。也就是说，$A$的每一列按照2中加权平铺，所有列按照不同的加权行平铺后，再将所有矩阵叠加。</p>\n</li>\n<li><p>第八点也可以这么想，先和第7点一样，$A$的每一列被$B$的每一列加权相加得到的列向量平铺开。</p>\n</li>\n</ol>\n<p>　　暂时想到这么多~以后遇到新的再加更~~刚刚双十一买了个耳机，貌似是第一次双十一等零点买东西，期待哇咔咔~</p>\n","site":{"data":{}},"excerpt":"","more":"<p>　　刚刚想把之前在办公室电脑上更新的文件deploy上去发现总是error,但在本地服务器上看又是没错的，后来发现重新hexo clean后再hexo g -d，问题就解决了，看来重启经常能解决问题^_^</p>\n<p>　　自从打定主意重新换方向开始后看书就发现，经常会被一大堆的矩阵分析晃花了眼，真后悔当年大学没好好学习这门课，貌似线性代数都因为在我转专业之后补修的，其实就去考了个试，相当于啥也没学嘛。。。。被折磨了这么久之后，我决定整理下目前接触到一些常用的小trick，对于我来说就是把数学符号翻译成大白话。开始~~~</p>\n<p>　　首先介绍一下待会要用到的一些概念：</p>\n<ol>\n<li>$1_k$:表示$k\\times 1$的全1列向量；</li>\n<li>$x=[x_1,x_2,…,x_D]^T$:$D\\times 1$的列向量,类似的有列向量$y$;</li>\n<li>$A=[a_1,a_2,…,a_D]$:表示$D\\times D$的方阵，其中$a_i$表示$A$的第$i$列；</li>\n<li>$B=[a_1,a_2,…,a_N]$:表示$D\\times N$的矩阵，其中$a_i$表示$B$的第$i$列；</li>\n</ol>\n<p>好的，下面解释一下一些矩阵计算是在干嘛，让矩阵计算说人话吧！</p>\n<ol>\n<li><p>$x^Ty$:内积，也就是$x_1y_1+x_2y_2+…+x_Dy_D$,当$x=y$时，就是对$x$中所有元素求平方和；以后看到这种长相的计算都应该在脑子里想到矮宽的括号和瘦高的括号相乘后变成一个标量的场景。</p>\n</li>\n<li><p>$yx^T=[x_1y,x_2y,…,x_Dy]=C$:即$C$的每一列$c_i$等于$x_iy$，相当于把$y$按照不同的系数平铺成一个矩阵，所以以后看到瘦高和矮宽结合就应该想到这个；</p>\n</li>\n<li><p>$x1_k^T=\\underbrace {[x_i, …, x_i]}_k$:相当于matlab里的<code>repmat(x,1,k)</code>，也就是把$x$复制$k$列，然后拼成一个矩阵；</p>\n</li>\n<li><p>$B1_N$：对矩阵的每行求和后变为一个列向量；</p>\n</li>\n<li><p>$1_D^TB$：对矩阵每列求和后变为一个行向量；</p>\n</li>\n<li><p>$1_D^T B 1_N$：对矩阵所有元素求和；</p>\n</li>\n<li><p>$Ax=a_1x_1+a_2x_2+…+a_Dx_D$,相当于$A$的每一列$a_i$通过对应的$x_i$值进行加权后相加得到,其中$A$可以不是方阵；</p>\n</li>\n<li><p>$AB=E$,$A$的第$i$列$a_i$和$B$的第$i$行$b_i$相乘得到$e_i=a_ib_i$，$e_i$是与X相同维度的矩阵($D\\times N$),$E=\\sum e_i$，就是把$D$个矩阵求和。也就是说，$A$的每一列按照2中加权平铺，所有列按照不同的加权行平铺后，再将所有矩阵叠加。</p>\n</li>\n<li><p>第八点也可以这么想，先和第7点一样，$A$的每一列被$B$的每一列加权相加得到的列向量平铺开。</p>\n</li>\n</ol>\n<p>　　暂时想到这么多~以后遇到新的再加更~~刚刚双十一买了个耳机，貌似是第一次双十一等零点买东西，期待哇咔咔~</p>\n"},{"title":"降维打击之LLE算法","date":"2017-09-29T13:55:34.000Z","mathjax":true,"_content":"\n## 背景\n---\n　　最近在温习之前了解过的spectral clustering 的时候接触到一个看着bigger满满的术语：manifold learing，然后顺藤摸瓜找到一篇2000年的science，不过他们当时并没有大肆炒这个manifold learning的概念，而是提出了一种叫做“local linear embedding”的降维算法，在处理所谓的流形的降维的时候，效果比PCA要好很多。于是我了解了下这个“简约而不简单”的LLE算法的具体实现方法，写一下我目前的理解。\n　　\n   ![Swiss roll](http://instudio.mabangapp.com/img/037/WJ058/WJ058g08.jpg)\n　　\n　　[图片来源](http://instudio.mabangapp.com/img/037/WJ058/WJ058g08.jpg)\n　　首先，所谓流形，我脑海里最直观的印象就是上图这种Swiss roll,我吃的时候喜欢把它整个摊开成一张饼再吃，其实这个过程就实现了对瑞士卷的降维操作，即从三维降到了两维。降维前，我们看到相邻的卷层之间看着距离很近，但其实摊开成饼状后才发现其实距离很远，所以如果不进行降维操作，如果根据近邻原则去判断相似性其实是不准确的。\n\n\n## 原理\n---\n　　LLE的原理其实是这样的：\n\n- 所谓局部线性，就是认为在整个数据集的某小范围内，数据是线性的，就比如虽然地球是圆的，但我们还是可以认为我们的篮球场是个平面；而这个“小范围”，最直接的办法就是k-近邻原则。这个“近邻”的判断也可以是不同的依据：比如欧氏距离，测地距离等。\n\n- 既然是线性，那么对每个数据点$x_i$(D维数据，即$D\\times 1$的列向量)，可以用其k近邻的数据点的线性组合来表示，即$x_i = \\sum_{j=1}^{k}w_{ji}x_{ji}$。其中，$w_i$是$k\\times 1$的列向量，$w_{ji}$是$w_i$的第$j$行,$x_{ji}$是$x_i$的第j个近邻点。\n\n\n- 通过使loss function最小化： \n$$ \\arg\\min \\limits_{W}\\sum_{i=1}^{N}(\\|x_i-\\sum_{j=1}^{k}w_{ji}x_{ji}\\|_2^2)$$\n得到权重系数$w = [w_1, w_2, ..., w_N]$,一共N个数据点，对应$N$列$w_i$。\n\n- 接下来是LLE中又一个假设：即认为将原始数据从D维降到d维后，$x_i(D\\times 1) \\rightarrow y_i(d\\times 1)$,其依旧可以表示为其k近邻的线性组合，且组合系数不变，即$w_i$,再一次通过最小化loss function:\n\n$$ \\arg\\min \\limits_{Y}\\sum_{i=1}^{N}(\\|y_i-\\sum_{j=1}^{k}w_{ji}y_{ji}\\|_2^2)$$\n\n得到降维后的数据。\n\n\n\n## 算法推导\n---\n### step 1：\n---\n运用k近邻算法得到每个数据的k近邻点：\n\n\n$$N_i = KNN(x_i,k), N_i = [x_{1i}, ..., x_{ki}]$$\n\n\n### step 2: 求解权重系数矩阵\n---\n即求解：\n\n\n$$ \\arg\\min \\limits_{W}\\sum_{i=1}^{N} \\|x_i - \\sum_{j=1}^{k}w_{ji}x_{ji}\\|^2, s.t. \\sum_{j=1}^k$$\n\n\n在推导之前，我们首先统一下数据的矩阵表达形式\n\n　　输入：$X = [x_1, x_2, ..., x_N], D\\times N$\n\n　　权重：$w = [w_1, w_2, ..., w_N], k\\times N$\n\n　　\n\n\n$$\\Phi(w)=\\sum_{i=1}^{N} \\|x_i - \\sum_{j=1}^{k}w_{ji}x_{ji}\\|^2$$\n$$=\\sum_{i=1}^{N} \\|\\sum_{j=1}^k (x_i-x_{ji})w_{ji}\\|^2$$\n$$=\\sum_{i=1}^N \\|(X_i-N_i)w_i\\|^2, X_i =\\underbrace {[x_i, ..., x_i]}_k, N_i = [x_{1i}, ..., x_{ki}]$$\n$$= \\sum_{i=1}^N w_i^T(X_i-N_i)^T(X_i-N_i)w_i$$\n$let\\ S_i = (X_i-N_i)^T(X_i-N_i)$ being the covariance matrix, then:\n$$\\Phi(w)=\\sum_{i=1}^N w_i^T S_i w_i$$\n拉格朗日乘子法：\n$$L(w_i) = w_i^T S_i w_i + \\lambda(w_i^T-1)$$\n求导：\n$$\\frac{\\partial L(w_i)}{\\partial w_i} = 2S_iw_i+\\lambda I = 0$$\n$$w_i = \\frac{S_i^{-1}I}{I^T S_i^{-1}I}$$\n　　\n　　就上述表达式而言，局部协方差矩阵$S_i$是个$k\\times k$的矩阵，其分母其实是$S_i$的逆矩阵的所有元素之和，而其分子是$S_i$的逆矩阵对行求和后得到的列向量。\n \n <!-- more -->\n\n### step 3: 映射到低维空间($d<D$)\n---\n\n即求解：\n$$\\arg \\min \\limits_{Y} \\Psi(Y) = \\sum_{i=1}^N\\|y_i - \\sum_{j=1}^k w_{ji}y_{ji}\\|^2, s.t. \\sum_{i=1}^N y_i = 0, \\sum_{i=1}^N y_i y_i^T = NI_{d\\times d}$$\n\n　　\n\n　　低维空间向量：$Y = [y_1, y_2, ..., y_N], d\\times N$\n\n\n首先，用一个$N\\times N$的稀疏矩阵(sparse matrix)$W$来表示$w$:\n\n　　　　　对$i$的近邻点j：   $W_{ji} = w_{ji}$;\n\n　　　　　否则:   $W_{ji} = 0$\n\n因此：\n$$\\sum_{j=1}^k w_{ji}y_{ji} = YW_i$$\n$W_i$是$W$方阵的第$i$列。所以\n$$\\Psi(Y) = \\sum_{i=1}^N\\|Y(I_i-W_i)\\|^2$$\n由矩阵论可知：对矩阵$A = [a_1, a_2, ..., a_N]$\n$$\\sum_i (a_i)^2 = \\sum_i a_i^T a_i = tr(AA^T)$$\n所以：\n$$\\Psi(Y) = tr(Y(I_i-W_i)(I_i-W_i)^TY^T)$$\n$$= tr(YMY^T),    M = (I_i-W_i)(I_i-W_i)^T$$\n再一次拉格朗日乘子法：\n$$L(Y) = YMY^T+\\lambda (YY^T-NI)$$\n求导：\n$$\\frac{\\partial L}{\\partial Y} = 2MY^T+2\\lambda Y^T = 0$$\n即\n$$MY^T = \\lambda'Y^T$$\n\n　　可见Y其实是M的特征向量构成的矩阵，为了将数据降到d维，我们只需要取M的最小的d个非零特征值对应的特征向量，而一般第一个最小的特征值接近0，我们将其舍弃，取前$[2， d+1]$个特征值对应的特征向量。\n\n## 思考\n---\n1. 在step 3中为什么是取d个最小的非零特征值，而不是最大的d个特征值呢？\n2. 怎样理解每一步的约束条件呢？\n\n\n输公式好累呀~~~~\n","source":"_posts/降维打击之LLE算法.md","raw":"---\ntitle: 降维打击之LLE算法\ndate: 2017-09-29 21:55:34\ntags: \n    - 机器学习\n    - 降维算法\n    - 随笔\nmathjax: true\n---\n\n## 背景\n---\n　　最近在温习之前了解过的spectral clustering 的时候接触到一个看着bigger满满的术语：manifold learing，然后顺藤摸瓜找到一篇2000年的science，不过他们当时并没有大肆炒这个manifold learning的概念，而是提出了一种叫做“local linear embedding”的降维算法，在处理所谓的流形的降维的时候，效果比PCA要好很多。于是我了解了下这个“简约而不简单”的LLE算法的具体实现方法，写一下我目前的理解。\n　　\n   ![Swiss roll](http://instudio.mabangapp.com/img/037/WJ058/WJ058g08.jpg)\n　　\n　　[图片来源](http://instudio.mabangapp.com/img/037/WJ058/WJ058g08.jpg)\n　　首先，所谓流形，我脑海里最直观的印象就是上图这种Swiss roll,我吃的时候喜欢把它整个摊开成一张饼再吃，其实这个过程就实现了对瑞士卷的降维操作，即从三维降到了两维。降维前，我们看到相邻的卷层之间看着距离很近，但其实摊开成饼状后才发现其实距离很远，所以如果不进行降维操作，如果根据近邻原则去判断相似性其实是不准确的。\n\n\n## 原理\n---\n　　LLE的原理其实是这样的：\n\n- 所谓局部线性，就是认为在整个数据集的某小范围内，数据是线性的，就比如虽然地球是圆的，但我们还是可以认为我们的篮球场是个平面；而这个“小范围”，最直接的办法就是k-近邻原则。这个“近邻”的判断也可以是不同的依据：比如欧氏距离，测地距离等。\n\n- 既然是线性，那么对每个数据点$x_i$(D维数据，即$D\\times 1$的列向量)，可以用其k近邻的数据点的线性组合来表示，即$x_i = \\sum_{j=1}^{k}w_{ji}x_{ji}$。其中，$w_i$是$k\\times 1$的列向量，$w_{ji}$是$w_i$的第$j$行,$x_{ji}$是$x_i$的第j个近邻点。\n\n\n- 通过使loss function最小化： \n$$ \\arg\\min \\limits_{W}\\sum_{i=1}^{N}(\\|x_i-\\sum_{j=1}^{k}w_{ji}x_{ji}\\|_2^2)$$\n得到权重系数$w = [w_1, w_2, ..., w_N]$,一共N个数据点，对应$N$列$w_i$。\n\n- 接下来是LLE中又一个假设：即认为将原始数据从D维降到d维后，$x_i(D\\times 1) \\rightarrow y_i(d\\times 1)$,其依旧可以表示为其k近邻的线性组合，且组合系数不变，即$w_i$,再一次通过最小化loss function:\n\n$$ \\arg\\min \\limits_{Y}\\sum_{i=1}^{N}(\\|y_i-\\sum_{j=1}^{k}w_{ji}y_{ji}\\|_2^2)$$\n\n得到降维后的数据。\n\n\n\n## 算法推导\n---\n### step 1：\n---\n运用k近邻算法得到每个数据的k近邻点：\n\n\n$$N_i = KNN(x_i,k), N_i = [x_{1i}, ..., x_{ki}]$$\n\n\n### step 2: 求解权重系数矩阵\n---\n即求解：\n\n\n$$ \\arg\\min \\limits_{W}\\sum_{i=1}^{N} \\|x_i - \\sum_{j=1}^{k}w_{ji}x_{ji}\\|^2, s.t. \\sum_{j=1}^k$$\n\n\n在推导之前，我们首先统一下数据的矩阵表达形式\n\n　　输入：$X = [x_1, x_2, ..., x_N], D\\times N$\n\n　　权重：$w = [w_1, w_2, ..., w_N], k\\times N$\n\n　　\n\n\n$$\\Phi(w)=\\sum_{i=1}^{N} \\|x_i - \\sum_{j=1}^{k}w_{ji}x_{ji}\\|^2$$\n$$=\\sum_{i=1}^{N} \\|\\sum_{j=1}^k (x_i-x_{ji})w_{ji}\\|^2$$\n$$=\\sum_{i=1}^N \\|(X_i-N_i)w_i\\|^2, X_i =\\underbrace {[x_i, ..., x_i]}_k, N_i = [x_{1i}, ..., x_{ki}]$$\n$$= \\sum_{i=1}^N w_i^T(X_i-N_i)^T(X_i-N_i)w_i$$\n$let\\ S_i = (X_i-N_i)^T(X_i-N_i)$ being the covariance matrix, then:\n$$\\Phi(w)=\\sum_{i=1}^N w_i^T S_i w_i$$\n拉格朗日乘子法：\n$$L(w_i) = w_i^T S_i w_i + \\lambda(w_i^T-1)$$\n求导：\n$$\\frac{\\partial L(w_i)}{\\partial w_i} = 2S_iw_i+\\lambda I = 0$$\n$$w_i = \\frac{S_i^{-1}I}{I^T S_i^{-1}I}$$\n　　\n　　就上述表达式而言，局部协方差矩阵$S_i$是个$k\\times k$的矩阵，其分母其实是$S_i$的逆矩阵的所有元素之和，而其分子是$S_i$的逆矩阵对行求和后得到的列向量。\n \n <!-- more -->\n\n### step 3: 映射到低维空间($d<D$)\n---\n\n即求解：\n$$\\arg \\min \\limits_{Y} \\Psi(Y) = \\sum_{i=1}^N\\|y_i - \\sum_{j=1}^k w_{ji}y_{ji}\\|^2, s.t. \\sum_{i=1}^N y_i = 0, \\sum_{i=1}^N y_i y_i^T = NI_{d\\times d}$$\n\n　　\n\n　　低维空间向量：$Y = [y_1, y_2, ..., y_N], d\\times N$\n\n\n首先，用一个$N\\times N$的稀疏矩阵(sparse matrix)$W$来表示$w$:\n\n　　　　　对$i$的近邻点j：   $W_{ji} = w_{ji}$;\n\n　　　　　否则:   $W_{ji} = 0$\n\n因此：\n$$\\sum_{j=1}^k w_{ji}y_{ji} = YW_i$$\n$W_i$是$W$方阵的第$i$列。所以\n$$\\Psi(Y) = \\sum_{i=1}^N\\|Y(I_i-W_i)\\|^2$$\n由矩阵论可知：对矩阵$A = [a_1, a_2, ..., a_N]$\n$$\\sum_i (a_i)^2 = \\sum_i a_i^T a_i = tr(AA^T)$$\n所以：\n$$\\Psi(Y) = tr(Y(I_i-W_i)(I_i-W_i)^TY^T)$$\n$$= tr(YMY^T),    M = (I_i-W_i)(I_i-W_i)^T$$\n再一次拉格朗日乘子法：\n$$L(Y) = YMY^T+\\lambda (YY^T-NI)$$\n求导：\n$$\\frac{\\partial L}{\\partial Y} = 2MY^T+2\\lambda Y^T = 0$$\n即\n$$MY^T = \\lambda'Y^T$$\n\n　　可见Y其实是M的特征向量构成的矩阵，为了将数据降到d维，我们只需要取M的最小的d个非零特征值对应的特征向量，而一般第一个最小的特征值接近0，我们将其舍弃，取前$[2， d+1]$个特征值对应的特征向量。\n\n## 思考\n---\n1. 在step 3中为什么是取d个最小的非零特征值，而不是最大的d个特征值呢？\n2. 怎样理解每一步的约束条件呢？\n\n\n输公式好累呀~~~~\n","slug":"降维打击之LLE算法","published":1,"updated":"2018-01-16T03:43:02.895Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcknckza000dsouydg0w1am9","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><hr>\n<p>　　最近在温习之前了解过的spectral clustering 的时候接触到一个看着bigger满满的术语：manifold learing，然后顺藤摸瓜找到一篇2000年的science，不过他们当时并没有大肆炒这个manifold learning的概念，而是提出了一种叫做“local linear embedding”的降维算法，在处理所谓的流形的降维的时候，效果比PCA要好很多。于是我了解了下这个“简约而不简单”的LLE算法的具体实现方法，写一下我目前的理解。<br>　　<br>   <img src=\"http://instudio.mabangapp.com/img/037/WJ058/WJ058g08.jpg\" alt=\"Swiss roll\"><br>　　<br>　　<a href=\"http://instudio.mabangapp.com/img/037/WJ058/WJ058g08.jpg\" target=\"_blank\" rel=\"noopener\">图片来源</a><br>　　首先，所谓流形，我脑海里最直观的印象就是上图这种Swiss roll,我吃的时候喜欢把它整个摊开成一张饼再吃，其实这个过程就实现了对瑞士卷的降维操作，即从三维降到了两维。降维前，我们看到相邻的卷层之间看着距离很近，但其实摊开成饼状后才发现其实距离很远，所以如果不进行降维操作，如果根据近邻原则去判断相似性其实是不准确的。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><hr>\n<p>　　LLE的原理其实是这样的：</p>\n<ul>\n<li><p>所谓局部线性，就是认为在整个数据集的某小范围内，数据是线性的，就比如虽然地球是圆的，但我们还是可以认为我们的篮球场是个平面；而这个“小范围”，最直接的办法就是k-近邻原则。这个“近邻”的判断也可以是不同的依据：比如欧氏距离，测地距离等。</p>\n</li>\n<li><p>既然是线性，那么对每个数据点$x_i$(D维数据，即$D\\times 1$的列向量)，可以用其k近邻的数据点的线性组合来表示，即$x_i = \\sum_{j=1}^{k}w_{ji}x_{ji}$。其中，$w_i$是$k\\times 1$的列向量，$w_{ji}$是$w_i$的第$j$行,$x_{ji}$是$x_i$的第j个近邻点。</p>\n</li>\n</ul>\n<ul>\n<li><p>通过使loss function最小化： </p>\n<script type=\"math/tex; mode=display\">\\arg\\min \\limits_{W}\\sum_{i=1}^{N}(\\|x_i-\\sum_{j=1}^{k}w_{ji}x_{ji}\\|_2^2)</script><p>得到权重系数$w = [w_1, w_2, …, w_N]$,一共N个数据点，对应$N$列$w_i$。</p>\n</li>\n<li><p>接下来是LLE中又一个假设：即认为将原始数据从D维降到d维后，$x_i(D\\times 1) \\rightarrow y_i(d\\times 1)$,其依旧可以表示为其k近邻的线性组合，且组合系数不变，即$w_i$,再一次通过最小化loss function:</p>\n</li>\n</ul>\n<script type=\"math/tex; mode=display\">\\arg\\min \\limits_{Y}\\sum_{i=1}^{N}(\\|y_i-\\sum_{j=1}^{k}w_{ji}y_{ji}\\|_2^2)</script><p>得到降维后的数据。</p>\n<h2 id=\"算法推导\"><a href=\"#算法推导\" class=\"headerlink\" title=\"算法推导\"></a>算法推导</h2><hr>\n<h3 id=\"step-1：\"><a href=\"#step-1：\" class=\"headerlink\" title=\"step 1：\"></a>step 1：</h3><hr>\n<p>运用k近邻算法得到每个数据的k近邻点：</p>\n<script type=\"math/tex; mode=display\">N_i = KNN(x_i,k), N_i = [x_{1i}, ..., x_{ki}]</script><h3 id=\"step-2-求解权重系数矩阵\"><a href=\"#step-2-求解权重系数矩阵\" class=\"headerlink\" title=\"step 2: 求解权重系数矩阵\"></a>step 2: 求解权重系数矩阵</h3><hr>\n<p>即求解：</p>\n<script type=\"math/tex; mode=display\">\\arg\\min \\limits_{W}\\sum_{i=1}^{N} \\|x_i - \\sum_{j=1}^{k}w_{ji}x_{ji}\\|^2, s.t. \\sum_{j=1}^k</script><p>在推导之前，我们首先统一下数据的矩阵表达形式</p>\n<p>　　输入：$X = [x_1, x_2, …, x_N], D\\times N$</p>\n<p>　　权重：$w = [w_1, w_2, …, w_N], k\\times N$</p>\n<p>　　</p>\n<script type=\"math/tex; mode=display\">\\Phi(w)=\\sum_{i=1}^{N} \\|x_i - \\sum_{j=1}^{k}w_{ji}x_{ji}\\|^2</script><script type=\"math/tex; mode=display\">=\\sum_{i=1}^{N} \\|\\sum_{j=1}^k (x_i-x_{ji})w_{ji}\\|^2</script><script type=\"math/tex; mode=display\">=\\sum_{i=1}^N \\|(X_i-N_i)w_i\\|^2, X_i =\\underbrace {[x_i, ..., x_i]}_k, N_i = [x_{1i}, ..., x_{ki}]</script><script type=\"math/tex; mode=display\">= \\sum_{i=1}^N w_i^T(X_i-N_i)^T(X_i-N_i)w_i</script><p>$let\\ S_i = (X_i-N_i)^T(X_i-N_i)$ being the covariance matrix, then:</p>\n<script type=\"math/tex; mode=display\">\\Phi(w)=\\sum_{i=1}^N w_i^T S_i w_i</script><p>拉格朗日乘子法：</p>\n<script type=\"math/tex; mode=display\">L(w_i) = w_i^T S_i w_i + \\lambda(w_i^T-1)</script><p>求导：</p>\n<script type=\"math/tex; mode=display\">\\frac{\\partial L(w_i)}{\\partial w_i} = 2S_iw_i+\\lambda I = 0</script><script type=\"math/tex; mode=display\">w_i = \\frac{S_i^{-1}I}{I^T S_i^{-1}I}</script><p>　　<br>　　就上述表达式而言，局部协方差矩阵$S_i$是个$k\\times k$的矩阵，其分母其实是$S_i$的逆矩阵的所有元素之和，而其分子是$S_i$的逆矩阵对行求和后得到的列向量。</p>\n <a id=\"more\"></a>\n<h3 id=\"step-3-映射到低维空间-d-lt-D\"><a href=\"#step-3-映射到低维空间-d-lt-D\" class=\"headerlink\" title=\"step 3: 映射到低维空间($d&lt;D$)\"></a>step 3: 映射到低维空间($d&lt;D$)</h3><hr>\n<p>即求解：</p>\n<script type=\"math/tex; mode=display\">\\arg \\min \\limits_{Y} \\Psi(Y) = \\sum_{i=1}^N\\|y_i - \\sum_{j=1}^k w_{ji}y_{ji}\\|^2, s.t. \\sum_{i=1}^N y_i = 0, \\sum_{i=1}^N y_i y_i^T = NI_{d\\times d}</script><p>　　</p>\n<p>　　低维空间向量：$Y = [y_1, y_2, …, y_N], d\\times N$</p>\n<p>首先，用一个$N\\times N$的稀疏矩阵(sparse matrix)$W$来表示$w$:</p>\n<p>　　　　　对$i$的近邻点j：   $W_{ji} = w_{ji}$;</p>\n<p>　　　　　否则:   $W_{ji} = 0$</p>\n<p>因此：</p>\n<script type=\"math/tex; mode=display\">\\sum_{j=1}^k w_{ji}y_{ji} = YW_i</script><p>$W_i$是$W$方阵的第$i$列。所以</p>\n<script type=\"math/tex; mode=display\">\\Psi(Y) = \\sum_{i=1}^N\\|Y(I_i-W_i)\\|^2</script><p>由矩阵论可知：对矩阵$A = [a_1, a_2, …, a_N]$</p>\n<script type=\"math/tex; mode=display\">\\sum_i (a_i)^2 = \\sum_i a_i^T a_i = tr(AA^T)</script><p>所以：</p>\n<script type=\"math/tex; mode=display\">\\Psi(Y) = tr(Y(I_i-W_i)(I_i-W_i)^TY^T)</script><script type=\"math/tex; mode=display\">= tr(YMY^T),    M = (I_i-W_i)(I_i-W_i)^T</script><p>再一次拉格朗日乘子法：</p>\n<script type=\"math/tex; mode=display\">L(Y) = YMY^T+\\lambda (YY^T-NI)</script><p>求导：</p>\n<script type=\"math/tex; mode=display\">\\frac{\\partial L}{\\partial Y} = 2MY^T+2\\lambda Y^T = 0</script><p>即</p>\n<script type=\"math/tex; mode=display\">MY^T = \\lambda'Y^T</script><p>　　可见Y其实是M的特征向量构成的矩阵，为了将数据降到d维，我们只需要取M的最小的d个非零特征值对应的特征向量，而一般第一个最小的特征值接近0，我们将其舍弃，取前$[2， d+1]$个特征值对应的特征向量。</p>\n<h2 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h2><hr>\n<ol>\n<li>在step 3中为什么是取d个最小的非零特征值，而不是最大的d个特征值呢？</li>\n<li>怎样理解每一步的约束条件呢？</li>\n</ol>\n<p>输公式好累呀~~~~</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><hr>\n<p>　　最近在温习之前了解过的spectral clustering 的时候接触到一个看着bigger满满的术语：manifold learing，然后顺藤摸瓜找到一篇2000年的science，不过他们当时并没有大肆炒这个manifold learning的概念，而是提出了一种叫做“local linear embedding”的降维算法，在处理所谓的流形的降维的时候，效果比PCA要好很多。于是我了解了下这个“简约而不简单”的LLE算法的具体实现方法，写一下我目前的理解。<br>　　<br>   <img src=\"http://instudio.mabangapp.com/img/037/WJ058/WJ058g08.jpg\" alt=\"Swiss roll\"><br>　　<br>　　<a href=\"http://instudio.mabangapp.com/img/037/WJ058/WJ058g08.jpg\" target=\"_blank\" rel=\"noopener\">图片来源</a><br>　　首先，所谓流形，我脑海里最直观的印象就是上图这种Swiss roll,我吃的时候喜欢把它整个摊开成一张饼再吃，其实这个过程就实现了对瑞士卷的降维操作，即从三维降到了两维。降维前，我们看到相邻的卷层之间看着距离很近，但其实摊开成饼状后才发现其实距离很远，所以如果不进行降维操作，如果根据近邻原则去判断相似性其实是不准确的。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><hr>\n<p>　　LLE的原理其实是这样的：</p>\n<ul>\n<li><p>所谓局部线性，就是认为在整个数据集的某小范围内，数据是线性的，就比如虽然地球是圆的，但我们还是可以认为我们的篮球场是个平面；而这个“小范围”，最直接的办法就是k-近邻原则。这个“近邻”的判断也可以是不同的依据：比如欧氏距离，测地距离等。</p>\n</li>\n<li><p>既然是线性，那么对每个数据点$x_i$(D维数据，即$D\\times 1$的列向量)，可以用其k近邻的数据点的线性组合来表示，即$x_i = \\sum_{j=1}^{k}w_{ji}x_{ji}$。其中，$w_i$是$k\\times 1$的列向量，$w_{ji}$是$w_i$的第$j$行,$x_{ji}$是$x_i$的第j个近邻点。</p>\n</li>\n</ul>\n<ul>\n<li><p>通过使loss function最小化： </p>\n<script type=\"math/tex; mode=display\">\\arg\\min \\limits_{W}\\sum_{i=1}^{N}(\\|x_i-\\sum_{j=1}^{k}w_{ji}x_{ji}\\|_2^2)</script><p>得到权重系数$w = [w_1, w_2, …, w_N]$,一共N个数据点，对应$N$列$w_i$。</p>\n</li>\n<li><p>接下来是LLE中又一个假设：即认为将原始数据从D维降到d维后，$x_i(D\\times 1) \\rightarrow y_i(d\\times 1)$,其依旧可以表示为其k近邻的线性组合，且组合系数不变，即$w_i$,再一次通过最小化loss function:</p>\n</li>\n</ul>\n<script type=\"math/tex; mode=display\">\\arg\\min \\limits_{Y}\\sum_{i=1}^{N}(\\|y_i-\\sum_{j=1}^{k}w_{ji}y_{ji}\\|_2^2)</script><p>得到降维后的数据。</p>\n<h2 id=\"算法推导\"><a href=\"#算法推导\" class=\"headerlink\" title=\"算法推导\"></a>算法推导</h2><hr>\n<h3 id=\"step-1：\"><a href=\"#step-1：\" class=\"headerlink\" title=\"step 1：\"></a>step 1：</h3><hr>\n<p>运用k近邻算法得到每个数据的k近邻点：</p>\n<script type=\"math/tex; mode=display\">N_i = KNN(x_i,k), N_i = [x_{1i}, ..., x_{ki}]</script><h3 id=\"step-2-求解权重系数矩阵\"><a href=\"#step-2-求解权重系数矩阵\" class=\"headerlink\" title=\"step 2: 求解权重系数矩阵\"></a>step 2: 求解权重系数矩阵</h3><hr>\n<p>即求解：</p>\n<script type=\"math/tex; mode=display\">\\arg\\min \\limits_{W}\\sum_{i=1}^{N} \\|x_i - \\sum_{j=1}^{k}w_{ji}x_{ji}\\|^2, s.t. \\sum_{j=1}^k</script><p>在推导之前，我们首先统一下数据的矩阵表达形式</p>\n<p>　　输入：$X = [x_1, x_2, …, x_N], D\\times N$</p>\n<p>　　权重：$w = [w_1, w_2, …, w_N], k\\times N$</p>\n<p>　　</p>\n<script type=\"math/tex; mode=display\">\\Phi(w)=\\sum_{i=1}^{N} \\|x_i - \\sum_{j=1}^{k}w_{ji}x_{ji}\\|^2</script><script type=\"math/tex; mode=display\">=\\sum_{i=1}^{N} \\|\\sum_{j=1}^k (x_i-x_{ji})w_{ji}\\|^2</script><script type=\"math/tex; mode=display\">=\\sum_{i=1}^N \\|(X_i-N_i)w_i\\|^2, X_i =\\underbrace {[x_i, ..., x_i]}_k, N_i = [x_{1i}, ..., x_{ki}]</script><script type=\"math/tex; mode=display\">= \\sum_{i=1}^N w_i^T(X_i-N_i)^T(X_i-N_i)w_i</script><p>$let\\ S_i = (X_i-N_i)^T(X_i-N_i)$ being the covariance matrix, then:</p>\n<script type=\"math/tex; mode=display\">\\Phi(w)=\\sum_{i=1}^N w_i^T S_i w_i</script><p>拉格朗日乘子法：</p>\n<script type=\"math/tex; mode=display\">L(w_i) = w_i^T S_i w_i + \\lambda(w_i^T-1)</script><p>求导：</p>\n<script type=\"math/tex; mode=display\">\\frac{\\partial L(w_i)}{\\partial w_i} = 2S_iw_i+\\lambda I = 0</script><script type=\"math/tex; mode=display\">w_i = \\frac{S_i^{-1}I}{I^T S_i^{-1}I}</script><p>　　<br>　　就上述表达式而言，局部协方差矩阵$S_i$是个$k\\times k$的矩阵，其分母其实是$S_i$的逆矩阵的所有元素之和，而其分子是$S_i$的逆矩阵对行求和后得到的列向量。</p>","more":"<h3 id=\"step-3-映射到低维空间-d-lt-D\"><a href=\"#step-3-映射到低维空间-d-lt-D\" class=\"headerlink\" title=\"step 3: 映射到低维空间($d&lt;D$)\"></a>step 3: 映射到低维空间($d&lt;D$)</h3><hr>\n<p>即求解：</p>\n<script type=\"math/tex; mode=display\">\\arg \\min \\limits_{Y} \\Psi(Y) = \\sum_{i=1}^N\\|y_i - \\sum_{j=1}^k w_{ji}y_{ji}\\|^2, s.t. \\sum_{i=1}^N y_i = 0, \\sum_{i=1}^N y_i y_i^T = NI_{d\\times d}</script><p>　　</p>\n<p>　　低维空间向量：$Y = [y_1, y_2, …, y_N], d\\times N$</p>\n<p>首先，用一个$N\\times N$的稀疏矩阵(sparse matrix)$W$来表示$w$:</p>\n<p>　　　　　对$i$的近邻点j：   $W_{ji} = w_{ji}$;</p>\n<p>　　　　　否则:   $W_{ji} = 0$</p>\n<p>因此：</p>\n<script type=\"math/tex; mode=display\">\\sum_{j=1}^k w_{ji}y_{ji} = YW_i</script><p>$W_i$是$W$方阵的第$i$列。所以</p>\n<script type=\"math/tex; mode=display\">\\Psi(Y) = \\sum_{i=1}^N\\|Y(I_i-W_i)\\|^2</script><p>由矩阵论可知：对矩阵$A = [a_1, a_2, …, a_N]$</p>\n<script type=\"math/tex; mode=display\">\\sum_i (a_i)^2 = \\sum_i a_i^T a_i = tr(AA^T)</script><p>所以：</p>\n<script type=\"math/tex; mode=display\">\\Psi(Y) = tr(Y(I_i-W_i)(I_i-W_i)^TY^T)</script><script type=\"math/tex; mode=display\">= tr(YMY^T),    M = (I_i-W_i)(I_i-W_i)^T</script><p>再一次拉格朗日乘子法：</p>\n<script type=\"math/tex; mode=display\">L(Y) = YMY^T+\\lambda (YY^T-NI)</script><p>求导：</p>\n<script type=\"math/tex; mode=display\">\\frac{\\partial L}{\\partial Y} = 2MY^T+2\\lambda Y^T = 0</script><p>即</p>\n<script type=\"math/tex; mode=display\">MY^T = \\lambda'Y^T</script><p>　　可见Y其实是M的特征向量构成的矩阵，为了将数据降到d维，我们只需要取M的最小的d个非零特征值对应的特征向量，而一般第一个最小的特征值接近0，我们将其舍弃，取前$[2， d+1]$个特征值对应的特征向量。</p>\n<h2 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h2><hr>\n<ol>\n<li>在step 3中为什么是取d个最小的非零特征值，而不是最大的d个特征值呢？</li>\n<li>怎样理解每一步的约束条件呢？</li>\n</ol>\n<p>输公式好累呀~~~~</p>"},{"title":"关于最近薛之谦事件的一点看法","date":"2017-09-23T10:33:07.000Z","_content":"　　好久不关注八卦，但最近“求锤得锤”的薛之谦实在太火，对各种网站的推送实在是想避也避不开，出于好奇，也作为曾经的半个粉丝，也算是了解了一下这个事件的大概。\n\n　　先说一下为啥是薛之谦的半个粉丝吧。记得还是上高一的时候，有个冬天在学校的广播听到了他的成名曲《认真的雪》，虽然不能说惊为天人，但确实也是特别喜欢。当时，宿舍有个室友买了一张薛之谦的专辑，应该是他的第一张专辑吧，好像叫《谦君一发》，现在对其中的《红尘女子》和《黄色枫叶》还是印象挺深刻。\n\n　　后来上大学之后，互联网变发达了，也陆陆续续听到他一些新歌，比如《传说》，《苏黎世的从前》等，但都没激起什么水花，毕竟这些歌和《认真的雪》相比，惊艳感几乎为零，甚至觉得相当俗气，词曲都相当平庸，唯一觉得不错的是觉得他唱歌的声音和感觉我很喜欢，不过也仅仅是没有忘掉这个曾经这个在高中时代就知道的歌手而已。　　\n\n<!-- more -->\n　　真正有点喜欢这个歌手是在我博士第三年的时候，当时非常痛苦，陷在自我否定与自我期盼的痛苦中无法自拔，然后恰巧在youtube上听到了他的新专辑，貌似叫《意外》吧，其中几首歌配上他那种苦情声线，刚好迎合了我的痛苦：比如《其实》，比如《方圆几里》。但即使如此，我依然觉得他是一个平庸的歌手，给我带不了那种惊艳感，像张宇技高一筹的苦情唱法，林志炫高岭之花的唱腔，林宥嘉那种粘稠的抑郁感等等等等，歌曲本身方面比他才华横竖都溢的更是数不胜数。所以我当时和人说：虽然薛之谦的歌曲俗不可耐，演唱可能也只是录音棚水平，但现在的我就喜欢他这种唱得我感同身受的歌。 在这之后他的《演员》再一次红遍大街小巷的时候，才觉得这次这首歌好像有了当年《认真的雪》的level，再加上他微博段子手的人设和他当年《我型我秀》面试的乌龙也算是一致，对这个明星还是有点好感。\n\n　　但过了不到一年，对薛之谦就半粉转路人了，因为他对综艺节目的热衷，各种神经质，尴尬且老气的搞笑手段，让我觉得这个人有点用力过猛，而且他的现场也算是验证了我对他“录音棚歌手”的猜测，简而言之就是知乎上那句总结：他的才华配不上他现在的名气。　后来他又频繁登上各大新闻头条，一会演唱会给前妻表白，一会又和前妻复婚，但都觉得无感了。戏剧性的是，当时他和前妻复婚的时候网络上有段子说薛之谦离婚又复婚是为了在上海买房，后来没想到真的扯出了现在微博上天天撕的李雨桐事件。\n\n　　随着这个事情的发酵，我才发现现如今明星卖人设可以到达如此程度。在了解这个事情之前，我虽然不喜欢薛之谦了，但至少觉得他是个努力且正面的人，因为他现如今的人设和十年前的选秀时表现出的性格也算是出入不大，没想到其实都是一场营销。另外这个事件倒是让我觉得事件的女主很牛：\n１.　单枪匹马撕薛之谦，而且丝毫不落下风；\n2.　每次发的实锤简直是逻辑缜密，有情有理有据有节，据说女主是华科新闻系毕业的，嗯，专业功底扎实，大写的“服”。感觉女主可以去开个公关公司了。\n3.　目前形势颇有一种得道多助，失道寡助的感觉。薛之谦目前找到公关水平，恰好碰上这届吃瓜群众智商在线，聊天记录和转账记录都被专业网友拿去做了技术分析，甚至录音都有热心群众实力担当起了字幕组重任。\n\n　　经历这个事件，再加上近期周杰发声否认当年的“舌吻”事件，真是深感荧屏的不真实。之前总觉得自己拿了的正面世界的剧本，经历了工作的人际关系，再带着这种理解去看待事情，发现原来拿到的是真实世界剧本。\n\n　　如果，还是不愿意改变自己去迎合社会是不是太天真呢？\n\n　　不知道。\n\n－－－－－　2017.09.23\n\n","source":"_posts/关于最近薛之谦事件的一点看法.md","raw":"---\ntitle: 关于最近薛之谦事件的一点看法\ndate: 2017-09-23 18:33:07\ntags: \n    - 随笔\n    - 娱乐八卦\n---\n　　好久不关注八卦，但最近“求锤得锤”的薛之谦实在太火，对各种网站的推送实在是想避也避不开，出于好奇，也作为曾经的半个粉丝，也算是了解了一下这个事件的大概。\n\n　　先说一下为啥是薛之谦的半个粉丝吧。记得还是上高一的时候，有个冬天在学校的广播听到了他的成名曲《认真的雪》，虽然不能说惊为天人，但确实也是特别喜欢。当时，宿舍有个室友买了一张薛之谦的专辑，应该是他的第一张专辑吧，好像叫《谦君一发》，现在对其中的《红尘女子》和《黄色枫叶》还是印象挺深刻。\n\n　　后来上大学之后，互联网变发达了，也陆陆续续听到他一些新歌，比如《传说》，《苏黎世的从前》等，但都没激起什么水花，毕竟这些歌和《认真的雪》相比，惊艳感几乎为零，甚至觉得相当俗气，词曲都相当平庸，唯一觉得不错的是觉得他唱歌的声音和感觉我很喜欢，不过也仅仅是没有忘掉这个曾经这个在高中时代就知道的歌手而已。　　\n\n<!-- more -->\n　　真正有点喜欢这个歌手是在我博士第三年的时候，当时非常痛苦，陷在自我否定与自我期盼的痛苦中无法自拔，然后恰巧在youtube上听到了他的新专辑，貌似叫《意外》吧，其中几首歌配上他那种苦情声线，刚好迎合了我的痛苦：比如《其实》，比如《方圆几里》。但即使如此，我依然觉得他是一个平庸的歌手，给我带不了那种惊艳感，像张宇技高一筹的苦情唱法，林志炫高岭之花的唱腔，林宥嘉那种粘稠的抑郁感等等等等，歌曲本身方面比他才华横竖都溢的更是数不胜数。所以我当时和人说：虽然薛之谦的歌曲俗不可耐，演唱可能也只是录音棚水平，但现在的我就喜欢他这种唱得我感同身受的歌。 在这之后他的《演员》再一次红遍大街小巷的时候，才觉得这次这首歌好像有了当年《认真的雪》的level，再加上他微博段子手的人设和他当年《我型我秀》面试的乌龙也算是一致，对这个明星还是有点好感。\n\n　　但过了不到一年，对薛之谦就半粉转路人了，因为他对综艺节目的热衷，各种神经质，尴尬且老气的搞笑手段，让我觉得这个人有点用力过猛，而且他的现场也算是验证了我对他“录音棚歌手”的猜测，简而言之就是知乎上那句总结：他的才华配不上他现在的名气。　后来他又频繁登上各大新闻头条，一会演唱会给前妻表白，一会又和前妻复婚，但都觉得无感了。戏剧性的是，当时他和前妻复婚的时候网络上有段子说薛之谦离婚又复婚是为了在上海买房，后来没想到真的扯出了现在微博上天天撕的李雨桐事件。\n\n　　随着这个事情的发酵，我才发现现如今明星卖人设可以到达如此程度。在了解这个事情之前，我虽然不喜欢薛之谦了，但至少觉得他是个努力且正面的人，因为他现如今的人设和十年前的选秀时表现出的性格也算是出入不大，没想到其实都是一场营销。另外这个事件倒是让我觉得事件的女主很牛：\n１.　单枪匹马撕薛之谦，而且丝毫不落下风；\n2.　每次发的实锤简直是逻辑缜密，有情有理有据有节，据说女主是华科新闻系毕业的，嗯，专业功底扎实，大写的“服”。感觉女主可以去开个公关公司了。\n3.　目前形势颇有一种得道多助，失道寡助的感觉。薛之谦目前找到公关水平，恰好碰上这届吃瓜群众智商在线，聊天记录和转账记录都被专业网友拿去做了技术分析，甚至录音都有热心群众实力担当起了字幕组重任。\n\n　　经历这个事件，再加上近期周杰发声否认当年的“舌吻”事件，真是深感荧屏的不真实。之前总觉得自己拿了的正面世界的剧本，经历了工作的人际关系，再带着这种理解去看待事情，发现原来拿到的是真实世界剧本。\n\n　　如果，还是不愿意改变自己去迎合社会是不是太天真呢？\n\n　　不知道。\n\n－－－－－　2017.09.23\n\n","slug":"关于最近薛之谦事件的一点看法","published":1,"updated":"2018-01-16T03:43:02.893Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcknckza000gsouydog32iuh","content":"<p>　　好久不关注八卦，但最近“求锤得锤”的薛之谦实在太火，对各种网站的推送实在是想避也避不开，出于好奇，也作为曾经的半个粉丝，也算是了解了一下这个事件的大概。</p>\n<p>　　先说一下为啥是薛之谦的半个粉丝吧。记得还是上高一的时候，有个冬天在学校的广播听到了他的成名曲《认真的雪》，虽然不能说惊为天人，但确实也是特别喜欢。当时，宿舍有个室友买了一张薛之谦的专辑，应该是他的第一张专辑吧，好像叫《谦君一发》，现在对其中的《红尘女子》和《黄色枫叶》还是印象挺深刻。</p>\n<p>　　后来上大学之后，互联网变发达了，也陆陆续续听到他一些新歌，比如《传说》，《苏黎世的从前》等，但都没激起什么水花，毕竟这些歌和《认真的雪》相比，惊艳感几乎为零，甚至觉得相当俗气，词曲都相当平庸，唯一觉得不错的是觉得他唱歌的声音和感觉我很喜欢，不过也仅仅是没有忘掉这个曾经这个在高中时代就知道的歌手而已。　　</p>\n<a id=\"more\"></a>\n<p>　　真正有点喜欢这个歌手是在我博士第三年的时候，当时非常痛苦，陷在自我否定与自我期盼的痛苦中无法自拔，然后恰巧在youtube上听到了他的新专辑，貌似叫《意外》吧，其中几首歌配上他那种苦情声线，刚好迎合了我的痛苦：比如《其实》，比如《方圆几里》。但即使如此，我依然觉得他是一个平庸的歌手，给我带不了那种惊艳感，像张宇技高一筹的苦情唱法，林志炫高岭之花的唱腔，林宥嘉那种粘稠的抑郁感等等等等，歌曲本身方面比他才华横竖都溢的更是数不胜数。所以我当时和人说：虽然薛之谦的歌曲俗不可耐，演唱可能也只是录音棚水平，但现在的我就喜欢他这种唱得我感同身受的歌。 在这之后他的《演员》再一次红遍大街小巷的时候，才觉得这次这首歌好像有了当年《认真的雪》的level，再加上他微博段子手的人设和他当年《我型我秀》面试的乌龙也算是一致，对这个明星还是有点好感。</p>\n<p>　　但过了不到一年，对薛之谦就半粉转路人了，因为他对综艺节目的热衷，各种神经质，尴尬且老气的搞笑手段，让我觉得这个人有点用力过猛，而且他的现场也算是验证了我对他“录音棚歌手”的猜测，简而言之就是知乎上那句总结：他的才华配不上他现在的名气。　后来他又频繁登上各大新闻头条，一会演唱会给前妻表白，一会又和前妻复婚，但都觉得无感了。戏剧性的是，当时他和前妻复婚的时候网络上有段子说薛之谦离婚又复婚是为了在上海买房，后来没想到真的扯出了现在微博上天天撕的李雨桐事件。</p>\n<p>　　随着这个事情的发酵，我才发现现如今明星卖人设可以到达如此程度。在了解这个事情之前，我虽然不喜欢薛之谦了，但至少觉得他是个努力且正面的人，因为他现如今的人设和十年前的选秀时表现出的性格也算是出入不大，没想到其实都是一场营销。另外这个事件倒是让我觉得事件的女主很牛：<br>１.　单枪匹马撕薛之谦，而且丝毫不落下风；<br>2.　每次发的实锤简直是逻辑缜密，有情有理有据有节，据说女主是华科新闻系毕业的，嗯，专业功底扎实，大写的“服”。感觉女主可以去开个公关公司了。<br>3.　目前形势颇有一种得道多助，失道寡助的感觉。薛之谦目前找到公关水平，恰好碰上这届吃瓜群众智商在线，聊天记录和转账记录都被专业网友拿去做了技术分析，甚至录音都有热心群众实力担当起了字幕组重任。</p>\n<p>　　经历这个事件，再加上近期周杰发声否认当年的“舌吻”事件，真是深感荧屏的不真实。之前总觉得自己拿了的正面世界的剧本，经历了工作的人际关系，再带着这种理解去看待事情，发现原来拿到的是真实世界剧本。</p>\n<p>　　如果，还是不愿意改变自己去迎合社会是不是太天真呢？</p>\n<p>　　不知道。</p>\n<p>－－－－－　2017.09.23</p>\n","site":{"data":{}},"excerpt":"<p>　　好久不关注八卦，但最近“求锤得锤”的薛之谦实在太火，对各种网站的推送实在是想避也避不开，出于好奇，也作为曾经的半个粉丝，也算是了解了一下这个事件的大概。</p>\n<p>　　先说一下为啥是薛之谦的半个粉丝吧。记得还是上高一的时候，有个冬天在学校的广播听到了他的成名曲《认真的雪》，虽然不能说惊为天人，但确实也是特别喜欢。当时，宿舍有个室友买了一张薛之谦的专辑，应该是他的第一张专辑吧，好像叫《谦君一发》，现在对其中的《红尘女子》和《黄色枫叶》还是印象挺深刻。</p>\n<p>　　后来上大学之后，互联网变发达了，也陆陆续续听到他一些新歌，比如《传说》，《苏黎世的从前》等，但都没激起什么水花，毕竟这些歌和《认真的雪》相比，惊艳感几乎为零，甚至觉得相当俗气，词曲都相当平庸，唯一觉得不错的是觉得他唱歌的声音和感觉我很喜欢，不过也仅仅是没有忘掉这个曾经这个在高中时代就知道的歌手而已。　　</p>","more":"<p>　　真正有点喜欢这个歌手是在我博士第三年的时候，当时非常痛苦，陷在自我否定与自我期盼的痛苦中无法自拔，然后恰巧在youtube上听到了他的新专辑，貌似叫《意外》吧，其中几首歌配上他那种苦情声线，刚好迎合了我的痛苦：比如《其实》，比如《方圆几里》。但即使如此，我依然觉得他是一个平庸的歌手，给我带不了那种惊艳感，像张宇技高一筹的苦情唱法，林志炫高岭之花的唱腔，林宥嘉那种粘稠的抑郁感等等等等，歌曲本身方面比他才华横竖都溢的更是数不胜数。所以我当时和人说：虽然薛之谦的歌曲俗不可耐，演唱可能也只是录音棚水平，但现在的我就喜欢他这种唱得我感同身受的歌。 在这之后他的《演员》再一次红遍大街小巷的时候，才觉得这次这首歌好像有了当年《认真的雪》的level，再加上他微博段子手的人设和他当年《我型我秀》面试的乌龙也算是一致，对这个明星还是有点好感。</p>\n<p>　　但过了不到一年，对薛之谦就半粉转路人了，因为他对综艺节目的热衷，各种神经质，尴尬且老气的搞笑手段，让我觉得这个人有点用力过猛，而且他的现场也算是验证了我对他“录音棚歌手”的猜测，简而言之就是知乎上那句总结：他的才华配不上他现在的名气。　后来他又频繁登上各大新闻头条，一会演唱会给前妻表白，一会又和前妻复婚，但都觉得无感了。戏剧性的是，当时他和前妻复婚的时候网络上有段子说薛之谦离婚又复婚是为了在上海买房，后来没想到真的扯出了现在微博上天天撕的李雨桐事件。</p>\n<p>　　随着这个事情的发酵，我才发现现如今明星卖人设可以到达如此程度。在了解这个事情之前，我虽然不喜欢薛之谦了，但至少觉得他是个努力且正面的人，因为他现如今的人设和十年前的选秀时表现出的性格也算是出入不大，没想到其实都是一场营销。另外这个事件倒是让我觉得事件的女主很牛：<br>１.　单枪匹马撕薛之谦，而且丝毫不落下风；<br>2.　每次发的实锤简直是逻辑缜密，有情有理有据有节，据说女主是华科新闻系毕业的，嗯，专业功底扎实，大写的“服”。感觉女主可以去开个公关公司了。<br>3.　目前形势颇有一种得道多助，失道寡助的感觉。薛之谦目前找到公关水平，恰好碰上这届吃瓜群众智商在线，聊天记录和转账记录都被专业网友拿去做了技术分析，甚至录音都有热心群众实力担当起了字幕组重任。</p>\n<p>　　经历这个事件，再加上近期周杰发声否认当年的“舌吻”事件，真是深感荧屏的不真实。之前总觉得自己拿了的正面世界的剧本，经历了工作的人际关系，再带着这种理解去看待事情，发现原来拿到的是真实世界剧本。</p>\n<p>　　如果，还是不愿意改变自己去迎合社会是不是太天真呢？</p>\n<p>　　不知道。</p>\n<p>－－－－－　2017.09.23</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjcknckyf0003souyjhj4l3wr","category_id":"cjcknckyu0005souysuyiomkp","_id":"cjcknckza000esouyu3o0wsmp"},{"post_id":"cjcknckyu0009souy8ok0uefl","category_id":"cjcknckza000csouyjf1slek3","_id":"cjcknckzq000jsouy4j05ukoc"}],"PostTag":[{"post_id":"cjcknckxz0000souy3koug13c","tag_id":"cjcknckyf0002souyqpalfjvh","_id":"cjcknckzq000isouydzjv662g"},{"post_id":"cjcknckxz0000souy3koug13c","tag_id":"cjcknckyu0007souyzpbu4t6b","_id":"cjcknckzq000ksouykhpp2kwf"},{"post_id":"cjcknckxz0000souy3koug13c","tag_id":"cjcknckza000asouyg8l2f80f","_id":"cjcknckzq000msouy38ie30x2"},{"post_id":"cjcknckxz0000souy3koug13c","tag_id":"cjcknckza000fsouyjd6tahew","_id":"cjcknckzq000nsouy2yzls6rn"},{"post_id":"cjcknckyf0001souy0ehqy9gz","tag_id":"cjcknckza000fsouyjd6tahew","_id":"cjcknckzq000psouy41681lwd"},{"post_id":"cjcknckyf0003souyjhj4l3wr","tag_id":"cjcknckyf0002souyqpalfjvh","_id":"cjcknckzq000ssouyoyb5gsqj"},{"post_id":"cjcknckyf0003souyjhj4l3wr","tag_id":"cjcknckzq000osouysikzfrkk","_id":"cjcknckzq000tsouyct7666ri"},{"post_id":"cjcknckyf0003souyjhj4l3wr","tag_id":"cjcknckza000fsouyjd6tahew","_id":"cjcknckzq000vsouy2i5so63y"},{"post_id":"cjcknckyf0004souyktlpnmsf","tag_id":"cjcknckyf0002souyqpalfjvh","_id":"cjcknckzq000xsouyv468ss64"},{"post_id":"cjcknckyf0004souyktlpnmsf","tag_id":"cjcknckyu0007souyzpbu4t6b","_id":"cjcknckzq000ysouy7sydy28l"},{"post_id":"cjcknckyf0004souyktlpnmsf","tag_id":"cjcknckza000fsouyjd6tahew","_id":"cjcknckzq0010souy5h8z45su"},{"post_id":"cjcknckyu0006souy4atz3t8w","tag_id":"cjcknckzq000wsouyyguxdzd5","_id":"cjcknckzq0012souyv05gmqct"},{"post_id":"cjcknckyu0006souy4atz3t8w","tag_id":"cjcknckzq000zsouyfdbmd517","_id":"cjcknckzq0013souy2yvde0zc"},{"post_id":"cjcknckyu0008souya53p7uzd","tag_id":"cjcknckyf0002souyqpalfjvh","_id":"cjcknckzq0015souyn18hgu8n"},{"post_id":"cjcknckyu0008souya53p7uzd","tag_id":"cjcknckzq000osouysikzfrkk","_id":"cjcknckzq0016souygzal4uf0"},{"post_id":"cjcknckyu0008souya53p7uzd","tag_id":"cjcknckyu0007souyzpbu4t6b","_id":"cjcknckzq0018souykk66k79g"},{"post_id":"cjcknckyu0009souy8ok0uefl","tag_id":"cjcknckza000fsouyjd6tahew","_id":"cjcknckzq001bsouyrbu5jgeb"},{"post_id":"cjcknckyu0009souy8ok0uefl","tag_id":"cjcknckzq0017souympwt36bl","_id":"cjcknckzq001csouye41n34bi"},{"post_id":"cjcknckyu0009souy8ok0uefl","tag_id":"cjcknckzq000zsouyfdbmd517","_id":"cjcknckzq001esouy92co9mmt"},{"post_id":"cjcknckza000bsouyloj29ai7","tag_id":"cjcknckzq000wsouyyguxdzd5","_id":"cjckncl05001gsouyta6bwzv5"},{"post_id":"cjcknckza000bsouyloj29ai7","tag_id":"cjcknckzq000zsouyfdbmd517","_id":"cjckncl05001hsouy6rkbdra0"},{"post_id":"cjcknckza000dsouydg0w1am9","tag_id":"cjcknckzq000wsouyyguxdzd5","_id":"cjckncl05001lsouycvgjyi3n"},{"post_id":"cjcknckza000dsouydg0w1am9","tag_id":"cjckncl05001isouygm2zldt0","_id":"cjckncl05001msouyih3i49id"},{"post_id":"cjcknckza000dsouydg0w1am9","tag_id":"cjcknckza000fsouyjd6tahew","_id":"cjckncl05001nsouy58wq5eo6"},{"post_id":"cjcknckza000gsouydog32iuh","tag_id":"cjcknckza000fsouyjd6tahew","_id":"cjckncl05001osouykx9tr1xr"},{"post_id":"cjcknckza000gsouydog32iuh","tag_id":"cjckncl05001ksouyff65za1c","_id":"cjckncl05001psouyo0hrfcz0"}],"Tag":[{"name":"Leetcode","_id":"cjcknckyf0002souyqpalfjvh"},{"name":"Data Structure","_id":"cjcknckyu0007souyzpbu4t6b"},{"name":"Linked list","_id":"cjcknckza000asouyg8l2f80f"},{"name":"随笔","_id":"cjcknckza000fsouyjd6tahew"},{"name":"algorithm","_id":"cjcknckzq000osouysikzfrkk"},{"name":"机器学习","_id":"cjcknckzq000wsouyyguxdzd5"},{"name":"读书笔记","_id":"cjcknckzq000zsouyfdbmd517"},{"name":"英语学习","_id":"cjcknckzq0017souympwt36bl"},{"name":"降维算法","_id":"cjckncl05001isouygm2zldt0"},{"name":"娱乐八卦","_id":"cjckncl05001ksouyff65za1c"}]}}